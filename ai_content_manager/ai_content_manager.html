<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ AI Content Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header Styles */
        .header {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header-title {
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .header-title h1 {
            font-size: 28px;
            color: #333;
        }


        /* Tab Navigation */
        .tab-navigation {
            gap: 4px;
            margin-bottom: 20px;
            background: #f8f9fa;
            padding: 4px;
            border-radius: 12px;
        }

        .tab-button {
            flex: 1;
            padding: 12px 20px;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            color: #6c757d;
            transition: all 0.2s ease;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
        }

        .tab-button.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .tab-button:not(.active):hover {
            background: rgba(102, 126, 234, 0.1);
            color: #495057;
        }


        /* Content Tabs */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Controls */
        .controls-row {
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 20px;
        }

        .main-controls {
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
        }

        .header-stats {
            gap: 16px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .left-controls {
            gap: 12px;
            align-items: center;
            flex: 1;
        }

        .right-stats {
            gap: 16px;
            align-items: center;
        }

        .model-selector {
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e9ecef;
        }

        .model-selector label {
            font-weight: 600;
            color: #495057;
        }

        .model-selector select {
            padding: 6px 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            background: white;
            font-size: 14px;
            min-width: 160px;
        }

        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s ease;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .ai-button {
            background: linear-gradient(45deg, #28a745, #20c997);
            font-size: 16px;
            padding: 14px 24px;
        }

        .clear-button {
            background: linear-gradient(45deg, #dc3545, #fd7e14);
        }

        .stat-item {
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #495057;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
            text-transform: uppercase;
            font-weight: 600;
        }

        .grid-controls {
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }


        /* Image Grid */
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .image-grid.grid-1 { grid-template-columns: 1fr; }
        .image-grid.grid-2 { grid-template-columns: repeat(2, 1fr); }
        .image-grid.grid-3 { grid-template-columns: repeat(3, 1fr); }
        .image-grid.grid-4 { grid-template-columns: repeat(4, 1fr); }
        .image-grid.grid-5 { grid-template-columns: repeat(5, 1fr); }
        .image-grid.grid-6 { grid-template-columns: repeat(6, 1fr); }

        .image-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .image-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
        }

        .image-thumbnail {
            width: 100%;
            height: 200px;
            background: #f8f9fa;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        .image-thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .image-info {
            padding: 16px;
        }

        .image-name {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            word-break: break-word;
        }

        .image-caption {
            font-size: 14px;
            font-weight: 500;
            color: #333;
            margin-bottom: 8px;
            padding: 4px;
            border: 1px solid transparent;
            border-radius: 4px;
            cursor: text;
            min-height: 20px;
        }

        .image-caption:empty::before {
            content: "Click to add caption...";
            color: #999;
            font-style: italic;
        }

        .image-caption:hover {
            background: #f0f0f0;
            border-color: #ddd;
        }

        .image-caption[contenteditable="true"]:focus {
            outline: none;
            background: #fff;
            border-color: #667eea;
        }

        .caption-container {
            margin-bottom: 8px;
        }

        .caption-label {
            font-size: 12px;
            font-weight: 600;
            color: #666;
            display: block;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .image-tags {
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 8px;
        }

        .image-details {
            font-size: 12px;
            color: #666;
            flex-direction: column;
            gap: 4px;
            margin-top: 8px;
        }

        .image-details.hidden {
            display: none;
        }

        .detail-row {
            align-items: center;
            gap: 6px;
        }

        .tag {
            background: #e3f2fd;
            color: #1976d2;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        /* Drag & Drop Area */
        .drag-drop-area {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .drag-drop-area.drag-over,
        .drag-drop-area.dragover {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }

        .drag-drop-text {
            font-size: 18px;
            color: white;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .drag-drop-hint {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
        }

        /* Progress */
        .progress-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-bar {
            background: #e9ecef;
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            background: linear-gradient(45deg, #28a745, #20c997);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        .progress-text {
            text-align: center;
            color: #495057;
            font-weight: 600;
        }

        /* Search modal styles */
        .search-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .search-modal.active {
            display: flex;
        }

        .search-box {
            background: white;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80%;
            overflow: auto;
        }

        .search-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 20px;
        }

        .search-results {
            max-height: 400px;
            overflow-y: auto;
        }

        .search-result-item {
            align-items: center;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 8px;
            border: 1px solid #eee;
        }

        .search-result-item:hover {
            background: #f5f5f5;
        }

        .search-result-thumb {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 6px;
            margin-right: 12px;
        }

        .primary-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
        }

        .primary-btn:hover {
            background: #5a67d8;
        }

        /* Auto-load Banner */
        .auto-load-banner {
            background: linear-gradient(45deg, #17a2b8, #6610f2);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            font-weight: 600;
            animation: slideIn 0.5s ease;
        }

        @keyframes slideIn {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(102, 126, 234, 0); }
            100% { box-shadow: 0 0 0 0 rgba(102, 126, 234, 0); }
        }

        /* Document-specific styles */
        .document-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .document-grid.grid-1 { grid-template-columns: 1fr; }
        .document-grid.grid-2 { grid-template-columns: repeat(2, 1fr); }
        .document-grid.grid-3 { grid-template-columns: repeat(3, 1fr); }
        .document-grid.grid-4 { grid-template-columns: repeat(4, 1fr); }
        .document-grid.grid-5 { grid-template-columns: repeat(5, 1fr); }
        .document-grid.grid-6 { grid-template-columns: repeat(6, 1fr); }

        /* Audio Grid Styles */
        .audio-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .audio-grid.grid-1 { grid-template-columns: 1fr; }
        .audio-grid.grid-2 { grid-template-columns: repeat(2, 1fr); }
        .audio-grid.grid-3 { grid-template-columns: repeat(3, 1fr); }
        .audio-grid.grid-4 { grid-template-columns: repeat(4, 1fr); }
        .audio-grid.grid-5 { grid-template-columns: repeat(5, 1fr); }
        .audio-grid.grid-6 { grid-template-columns: repeat(6, 1fr); }

        .audio-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .audio-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .audio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .audio-type {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-transform: uppercase;
        }

        .audio-type.mp3 { background: #FF5722; }
        .audio-type.wav { background: #2196F3; }
        .audio-type.flac { background: #4CAF50; }
        .audio-type.aac { background: #FF9800; }
        .audio-type.ogg { background: #9C27B0; }
        .audio-type.m4a { background: #607D8B; }

        .audio-content {
            padding: 16px;
        }

        .audio-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.3;
        }

        .audio-player {
            width: 100%;
            margin: 12px 0;
            background: #f8f9fa;
            border-radius: 6px;
            padding: 8px;
        }

        .audio-player audio {
            width: 100%;
            height: 32px;
        }

        .audio-summary {
            font-size: 13px;
            color: #666;
            margin: 8px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            min-height: 36px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .audio-summary:hover {
            background: #e9ecef;
        }

        .audio-summary[contenteditable="true"] {
            background: #fff3cd;
            border: 2px solid #ffc107;
            outline: none;
        }

        .summary-label {
            font-size: 11px;
            font-weight: 600;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
            display: block;
        }

        .summary-content {
            font-size: 13px;
            color: #333;
            line-height: 1.4;
        }

        .summary-placeholder {
            color: #6c757d;
            font-style: italic;
        }

        .audio-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
        }

        .audio-attributes {
            font-size: 12px;
            color: #6c757d;
            margin: 8px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .attribute-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .attribute-row:last-child {
            margin-bottom: 0;
        }

        .attribute-label {
            font-weight: 600;
        }

        .confidence-score {
            font-size: 11px;
            color: #6c757d;
            margin-top: 8px;
            text-align: center;
        }

        .confidence-text {
            padding: 4px 8px;
            background: #e3f2fd;
            border-radius: 4px;
            display: inline-block;
        }

        /* Video Grid Styles */
        .video-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .video-grid.grid-1 { grid-template-columns: 1fr; }
        .video-grid.grid-2 { grid-template-columns: repeat(2, 1fr); }
        .video-grid.grid-3 { grid-template-columns: repeat(3, 1fr); }
        .video-grid.grid-4 { grid-template-columns: repeat(4, 1fr); }
        .video-grid.grid-5 { grid-template-columns: repeat(5, 1fr); }
        .video-grid.grid-6 { grid-template-columns: repeat(6, 1fr); }

        .video-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            min-height: 280px;
        }

        .video-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }

        .video-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .video-type {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            color: white;
            text-transform: uppercase;
        }

        .video-type.mp4 { background: #e3f2fd; color: #1976d2; }
        .video-type.avi { background: #f3e5f5; color: #7b1fa2; }
        .video-type.mov { background: #e8f5e8; color: #388e3c; }
        .video-type.wmv { background: #fff3e0; color: #f57c00; }
        .video-type.mkv { background: #fce4ec; color: #c2185b; }
        .video-type.webm { background: #e0f2f1; color: #00796b; }

        .video-content {
            padding: 16px;
        }

        .video-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            font-size: 14px;
            line-height: 1.3;
            word-break: break-word;
        }

        .video-thumbnail {
            width: 100%;
            height: 140px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            overflow: hidden;
            position: relative;
        }

        .video-thumbnail:hover {
            transform: scale(1.02);
        }

        .video-thumbnail video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-thumbnail .play-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .video-thumbnail:hover .play-icon {
            background: rgba(0, 0, 0, 0.8);
            transform: translate(-50%, -50%) scale(1.1);
        }

        .video-summary {
            font-size: 13px;
            color: #666;
            margin-bottom: 12px;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            background: #f8f9fa;
            min-height: 36px;
            display: flex;
            align-items: center;
            line-height: 1.3;
        }

        .video-summary:hover {
            background: #e9ecef;
        }

        .video-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
        }

        .video-attributes {
            font-size: 12px;
            color: #6c757d;
            margin: 8px 0;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        .video-player-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .video-player-modal.active {
            display: flex;
        }

        .video-player-container {
            max-width: 90%;
            max-height: 90%;
            background: white;
            border-radius: 12px;
            padding: 20px;
            overflow: hidden;
            position: relative;
        }

        .video-player-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
            gap: 16px;
        }

        .video-player-close {
            background: #f8f9fa;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 16px;
            color: #666;
            flex-shrink: 0;
        }

        .video-player-close:hover {
            background: #e9ecef;
            color: #333;
        }

        .video-player video {
            width: 100%;
            max-width: 800px;
            height: auto;
            border-radius: 8px;
        }

        .document-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }

        .document-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
        }

        .document-header {
            position: relative;
            padding: 16px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-bottom: 1px solid #dee2e6;
        }

        .document-type {
            position: absolute;
            top: 8px;
            right: 8px;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .document-type.pdf { background: #F44336; }
        .document-type.docx { background: #2196F3; }
        .document-type.txt { background: #4CAF50; }
        .document-type.rtf { background: #9C27B0; }
        .document-type.md { background: #FF9800; }

        .ai-indicator {
            position: absolute;
            top: 8px;
            left: 8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .ai-indicator.analyzed {
            background: #4CAF50;
            color: white;
        }

        .document-content {
            padding: 16px;
        }

        .document-title {
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
            font-size: 14px;
            word-break: break-word;
        }

        .document-summary {
            color: #666;
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 12px;
            cursor: text;
            padding: 8px;
            border: 1px solid transparent;
            border-radius: 4px;
            min-height: 60px;
        }

        .document-summary:empty::before {
            content: "Click to add summary...";
            color: #999;
            font-style: italic;
        }

        .document-summary:hover {
            background-color: #f8f9fa;
        }

        .document-summary[contenteditable="true"]:focus {
            outline: none;
            border-color: #667eea;
            background: #fff;
        }

        .document-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 12px;
        }

        .document-preview {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 12px;
            font-size: 12px;
            line-height: 1.4;
            color: #666;
            max-height: 100px;
            overflow: hidden;
            position: relative;
        }

        .document-details {
            font-size: 12px;
            color: #666;
            flex-direction: column;
            gap: 4px;
        }

        .document-details.hidden {
            display: none;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .tab-button {
                font-size: 12px;
                padding: 10px 12px;
            }
            
            .tab-button .count {
                display: none;
            }
            
            .controls-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .main-controls {
                justify-content: center;
            }
            
            .header-stats {
                justify-content: center;
            }
        }
        
        /* Layout Classes */
        .controls-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .combined-row {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
            padding: 10px 0;
            border-bottom: 1px solid #e9ecef;
            width: 100%;
        }

        .button-row {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            padding: 10px 0;
            width: 100%;
        }

        .buttons-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            width: 100%;
        }
\n    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-title">
                <h1>üöÄ AI Content Manager</h1>
            </div>
            
            <!-- Tab Navigation -->
            <div class="tab-navigation">
                <button class="tab-button active" onclick="switchTab('images')" id="imagesTab">
                    üñºÔ∏è Images
                </button>
                <button class="tab-button" onclick="switchTab('documents')" id="documentsTab">
                    üìÑ Documents
                </button>
                <button class="tab-button" onclick="switchTab('audios')" id="audiosTab">
                    üéµ Audios
                </button>
                <button class="tab-button" onclick="switchTab('videos')" id="videosTab">
                    üé¨ Videos
                </button>
            </div>
        </div>

        <!-- Auto-load Banner -->
        <div class="auto-load-banner" id="autoLoadBanner" style="display: none;">
            üéâ Auto-loaded sample images from contents/image folder! Try the AI analysis or add your own content.
        </div>

        <!-- Video Player Modal -->
        <div class="video-player-modal" id="videoPlayerModal">
            <div class="video-player-container">
                <div class="video-player-header">
                    <h3 id="videoPlayerTitle" style="margin: 0; font-size: 16px; line-height: 1.3; word-break: break-word; flex: 1;">Video Title</h3>
                    <button class="video-player-close" onclick="closeVideoPlayer()">√ó</button>
                </div>
                <video id="videoPlayerElement" controls style="width: 100%; max-width: 800px; height: auto; border-radius: 8px;">
                    Your browser does not support the video tag.
                </video>
            </div>
        </div>

        <!-- Search Modal -->
        <div class="search-modal" id="searchModal">
            <div class="search-box">
                <h2>üîç AI-Powered Image Search</h2>
                <input type="text" class="search-input" id="searchInput" placeholder="Search by filename, AI tags, or content..." oninput="performSemanticSearch()">
                <div class="search-results" id="searchResults"></div>
                <button class="primary-btn" onclick="closeSearchModal()" style="margin-top: 20px;">Close</button>
            </div>
        </div>

        <!-- Progress Container -->
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Initializing AI model...</div>
        </div>

        <!-- Images Tab Content -->
        <div class="tab-content active" id="imagesContent">
            <div class="header">
                <div class="controls-section">
                    <!-- Combined Model and Widgets Row -->
                    <div class="combined-row">
                        <div class="model-selector">
                            <label for="aiModel">üß† AI Model:</label>
                            <select id="aiModel" onchange="handleModelChange()">
                                <option value="mobilenet">MobileNet v2 (Fast, Basic)</option>
                                <option value="efficientnet">EfficientNet (Balanced)</option>
                                <option value="mediapipe">MediaPipe (Best Accuracy)</option>
                            </select>
                        </div>
                        
                        <div class="grid-layout-control">
                            <label for="imageGridSelect">üìê Grid Layout:</label>
                            <select id="imageGridSelect" onchange="updateGridSize(this.value)">
                                <option value="1">1 per row</option>
                                <option value="2">2 per row</option>
                                <option value="3" selected>3 per row</option>
                                <option value="4">4 per row</option>
                                <option value="5">5 per row</option>
                                <option value="6">6 per row</option>
                            </select>
                        </div>
                        
                        <div class="attributes-toggle">
                            <input type="checkbox" id="showAttributes" onchange="toggleAttributes()" checked>
                            <label for="showAttributes">Show details</label>
                        </div>
                        
                        <div class="stat-item">
                            <span class="stat-value" id="totalImages">0</span>
                            <span class="stat-label">Images</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="analyzedImages">0</span>
                            <span class="stat-label">Analyzed</span>
                        </div>
                    </div>
                    
                    <!-- Buttons Row -->
                    <div class="buttons-row">
                        <button id="selectFiles">üìÅ Select Images</button>
                        <input type="file" id="filesInput" multiple style="display: none;" accept="image/*">
                        <button id="selectFolder">üìÇ Select Folder</button>
                        <input type="file" id="folderInput" webkitdirectory directory multiple style="display: none;" accept="image/*">
                        <button id="aiAnalyzeBtn" onclick="analyzeImages()" disabled class="ai-button">
                            <span id="aiAnalyzeIcon">üß†</span>
                            <span id="aiAnalyzeText">AI Analyze</span>
                        </button>
                        <button onclick="openSearch()">üîç AI Search</button>
                        <button onclick="exportMetadata()">üíæ Export</button>
                        <button onclick="importMetadata()">üìÇ Import</button>
                        <button onclick="startSlideshow()" id="slideshowBtn" disabled>‚ñ∂Ô∏è Slideshow</button>
                        <button onclick="clearGrid()" class="clear-button">üóëÔ∏è Clear Grid</button>
                    </div>
                </div>
            </div>

            <div class="drag-drop-area" id="dragDropArea">
                <div class="drag-drop-text">üìÅ Drag & Drop Images Here</div>
                <div class="drag-drop-hint">Or use the buttons above to select files</div>
            </div>

            <div class="image-grid" id="imageGrid">
                <!-- Images will be dynamically loaded here -->
            </div>
        </div>

        <!-- Documents Tab Content -->
        <div class="tab-content" id="documentsContent">
            <div class="header">
                <div class="controls-section">
                    <!-- AI Model and Widgets Row -->
                    <div class="combined-row">
                        <div class="model-selector">
                            <label for="docAiModel">üß† AI Model:</label>
                            <select id="docAiModel" onchange="handleDocumentModelChange()">
                                <option value="sentencebert">Sentence-BERT (Fast Embedding)</option>
                                <option value="distilbert">DistilBERT (Classification)</option>
                                <option value="universal">Universal Encoder (Advanced)</option>
                            </select>
                        </div>
                        
                        <div class="grid-layout-control">
                            <label for="docGridSelect">üìê Grid Layout:</label>
                            <select id="docGridSelect" onchange="updateDocumentGrid(this.value)">
                                <option value="1">1 per row</option>
                                <option value="2">2 per row</option>
                                <option value="3" selected>3 per row</option>
                                <option value="4">4 per row</option>
                                <option value="5">5 per row</option>
                                <option value="6">6 per row</option>
                            </select>
                        </div>
                        
                        <div class="attributes-toggle">
                            <input type="checkbox" id="docShowAttributes" onchange="toggleDocumentAttributes()" checked>
                            <label for="docShowAttributes">Show details</label>
                        </div>
                        
                        <div class="stat-item">
                            <span class="stat-value" id="totalDocuments">0</span>
                            <span class="stat-label">Documents</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="analyzedDocuments">0</span>
                            <span class="stat-label">Analyzed</span>
                        </div>
                    </div>
                    
                    <!-- Buttons Row -->
                    <div class="buttons-row">
                        <button id="selectDocFiles">üìÅ Select Documents</button>
                        <input type="file" id="docFilesInput" multiple style="display: none;" accept=".txt,.pdf,.docx,.rtf,.md,text/plain,application/pdf">
                        <button id="selectDocFolder">üìÇ Select Folder</button>
                        <input type="file" id="docFolderInput" webkitdirectory directory multiple style="display: none;">
                        <button id="docAiAnalyzeBtn" onclick="analyzeDocuments()" disabled class="ai-button">
                            <span id="docAiAnalyzeIcon">üß†</span>
                            <span id="docAiAnalyzeText">AI Analyze</span>
                        </button>
                        <button onclick="showDocumentSearch()">üîç AI Search</button>
                        <button onclick="exportDocumentMetadata()">üíæ Export</button>
                        <button onclick="importDocumentMetadata()">üìÇ Import</button>
                        <button onclick="clearDocumentGrid()" class="clear-button">üóëÔ∏è Clear Grid</button>
                    </div>
                </div>
            </div>

            <div class="drag-drop-area" id="docDragDropArea">
                <div class="drag-drop-text">üìÑ Drag & Drop Documents Here</div>
                <div class="drag-drop-hint">Supports TXT, PDF, DOCX, RTF, MD files</div>
            </div>

            <div class="document-grid" id="documentGrid">
                <!-- Documents will be dynamically loaded here -->
            </div>
        </div>

        <div class="tab-content" id="audiosContent">
            <div class="header">
                <div class="controls-section">
                    <!-- First Row: AI Model, Grid Layout, Show Details, Stats -->
                    <div class="combined-row">
                        <div class="model-selector">
                            <label for="audioAiModel">üß† AI Model:</label>
                            <select id="audioAiModel" onchange="handleAudioModelChange()">
                                <option value="audiobert">Audio-BERT (Fast Embedding)</option>
                                <option value="musiccnn">MusicCNN (Music Analysis)</option>
                                <option value="universal">Universal Audio (Advanced)</option>
                            </select>
                        </div>
                        
                        <div class="grid-layout-control">
                            <label for="audioGridSelect">üìê Grid Layout:</label>
                            <select id="audioGridSelect" onchange="updateAudioGrid(this.value)">
                                <option value="1">1 per row</option>
                                <option value="2">2 per row</option>
                                <option value="3" selected>3 per row</option>
                                <option value="4">4 per row</option>
                                <option value="5">5 per row</option>
                                <option value="6">6 per row</option>
                            </select>
                        </div>
                        
                        <div class="attributes-toggle">
                            <input type="checkbox" id="audioShowAttributes" onchange="toggleAudioAttributes()" checked>
                            <label for="audioShowAttributes">Show details</label>
                        </div>
                        
                        <div class="stat-item">
                            <span class="stat-value" id="totalAudios">0</span>
                            <span class="stat-label">Audios</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value" id="analyzedAudios">0</span>
                            <span class="stat-label">Analyzed</span>
                        </div>
                    </div>
                    
                    <!-- Second Row: All Action Buttons -->
                    <div class="button-row">
                        <button onclick="selectAudios()">üìÅ Select Files</button>
                        <button onclick="selectAudioFolder()">üìÇ Select Folder</button>
                        <button id="audioAiAnalyzeBtn" onclick="analyzeAudios()" disabled class="ai-button">
                            <span id="audioAiAnalyzeIcon">üéµ</span>
                            <span id="audioAiAnalyzeText">AI Analyze</span>
                        </button>
                        <button onclick="showAudioSearch()">üîç AI Search</button>
                        <button onclick="exportAudioMetadata()">üíæ Export</button>
                        <button onclick="importAudioMetadata()">üìÇ Import</button>
                        <button onclick="clearAudioGrid()" class="clear-button">üóëÔ∏è Clear Grid</button>
                    </div>
                </div>
            </div>

            <div class="drag-drop-area" id="audioDragDropArea">
                <div class="drag-drop-text">üéµ Drag & Drop Audio Files Here</div>
                <div class="drag-drop-hint">Supports MP3, WAV, FLAC, AAC, OGG, M4A files</div>
            </div>

            <div class="audio-grid" id="audioGrid">
                <!-- Audio files will be dynamically loaded here -->
            </div>
        </div>

        <div class="tab-content" id="videosContent">
            <div class="header">
                <div class="combined-row">
                    <div class="model-selector">
                        <label for="videoAiModel">üß† AI Model:</label>
                        <select id="videoAiModel" onchange="handleVideoModelChange()">
                            <option value="videobert">Video-BERT (Fast Embedding)</option>
                            <option value="videomae">VideoMAE (Scene Recognition)</option>
                            <option value="universal">Universal Video (Advanced)</option>
                        </select>
                    </div>
                    <div class="grid-layout-control">
                        <label for="videoGridSelect">üìê Grid Layout:</label>
                        <select id="videoGridSelect" onchange="updateVideoGridSize(this.value)">
                            <option value="1">1 per row</option>
                            <option value="2">2 per row</option>
                            <option value="3" selected>3 per row</option>
                            <option value="4">4 per row</option>
                            <option value="5">5 per row</option>
                            <option value="6">6 per row</option>
                        </select>
                    </div>
                    <label class="checkbox-label">
                        <input type="checkbox" id="videoShowDetails" onchange="toggleVideoFileInfo(this.checked)" checked>
                        Show details
                    </label>
                    <div class="stat-item">
                        üìπ Videos: <span class="stat-number" id="videoCount">0</span>
                    </div>
                    <div class="stat-item">
                        üé¨ Analyzed: <span class="stat-number" id="videoAnalyzedCount">0</span>
                    </div>
                </div>
                <div class="button-row">
                    <button onclick="selectVideoFiles()">üìÅ Select Files</button>
                    <button onclick="selectVideoFolder()">üìÇ Select Folder</button>
                    <button id="videoAiAnalyzeBtn" onclick="analyzeVideos()" disabled class="ai-button">
                        üé¨ AI Analyze
                    </button>
                    <button onclick="openVideoSearch()">üîç AI Search</button>
                    <button onclick="exportVideoMetadata()">üíæ Export</button>
                    <button onclick="importVideoMetadata()">üì• Import</button>
                    <button onclick="clearVideoGrid()" class="clear-button">üóëÔ∏è Clear Grid</button>
                </div>
            </div>

            <div class="drag-drop-area" id="videoDragDropArea">
                <div class="drag-drop-text">üé¨ Drag & Drop Videos Here</div>
                <div class="drag-drop-hint">Supports MP4, AVI, MOV, WMV, MKV, WebM, FLV, 3GP files</div>
            </div>

            <div class="video-grid" id="videoGrid">
                <!-- Video files will be dynamically loaded here -->
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    
    <script>
        // Global variables
        let images = [];
        let currentModel = null;
        let modelType = 'mobilenet';
        let modelLoaded = false;
        let isAnalyzing = false;
        let aiData = {};
        let captions = {};
        let currentTab = 'images';

        // Model configurations
        const modelConfigs = {
            mobilenet: {
                name: 'MobileNet v2',
                icon: 'üß†',
                color: 'model-mobilenet',
                size: '14MB',
                loadFunc: loadMobileNet
            },
            efficientnet: {
                name: 'EfficientNet',
                icon: 'üéØ',
                color: 'model-efficientnet', 
                size: '20MB',
                loadFunc: loadEfficientNet
            },
            mediapipe: {
                name: 'MediaPipe',
                icon: 'üöÄ',
                color: 'model-mediapipe',
                size: '25MB', 
                loadFunc: loadMediaPipe
            }
        };

        // Initialize app - MAIN DOMContentLoaded
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded - initializing app...');
            
            // Initialize AI models
            updateModelDisplay();
            loadSelectedModel();
            
            // Set up file selection buttons
            const selectFilesBtn = document.getElementById('selectFiles');
            const selectFolderBtn = document.getElementById('selectFolder');
            const filesInput = document.getElementById('filesInput');
            const folderInput = document.getElementById('folderInput');
            const dropZone = document.getElementById('dragDropArea');

            console.log('Setting up event listeners...');
            console.log('selectFilesBtn:', selectFilesBtn);
            console.log('selectFolderBtn:', selectFolderBtn);
            console.log('filesInput:', filesInput);
            console.log('folderInput:', folderInput);

            // Event Listeners
            if (selectFilesBtn && filesInput) {
                selectFilesBtn.addEventListener('click', () => {
                    console.log('Select Files button clicked');
                    filesInput.click();
                });
                filesInput.addEventListener('change', handleFilesSelect);
            } else {
                console.error('selectFilesBtn or filesInput not found!');
            }
            
            if (selectFolderBtn && folderInput) {
                selectFolderBtn.addEventListener('click', () => {
                    console.log('Select Folder button clicked');
                    folderInput.click();
                });
                folderInput.addEventListener('change', handleFolderSelect);
            } else {
                console.error('selectFolderBtn or folderInput not found!');
            }

            // Drag and Drop
            if (dropZone) {
                dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('dragover');
                });

                dropZone.addEventListener('dragleave', () => {
                    dropZone.classList.remove('dragover');
                });

                dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('dragover');
                    handleDroppedFiles(e.dataTransfer.files);
                });
            } else {
                console.error('dropZone not found!');
            }
            
            // Initialize with empty grid ready for user content
            console.log('App initialization complete');
        });

        // Tab Management
        function switchTab(tabName) {
            // Update active tab button
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Update active content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + 'Content').classList.add('active');
            
            currentTab = tabName;
        }


        // Clear Grid functionality
        function clearGrid() {
            if (images.length === 0) {
                alert('Grid is already empty.');
                return;
            }
            
            if (confirm('Are you sure you want to clear all images from the grid? This will remove all loaded images and their analysis data.')) {
                images = [];
                aiData = {};
                captions = {};
                renderImages();
                updateStats();
                document.getElementById('autoLoadBanner').style.display = 'none';
            }
        }


        // Handler functions
        function handleFilesSelect(event) {
            console.log('handleFilesSelect called with files:', event.target.files);
            const files = Array.from(event.target.files);
            loadImages(files);
        }

        function handleFolderSelect(event) {
            console.log('handleFolderSelect called with files:', event.target.files);
            const files = Array.from(event.target.files);
            loadImages(files);
        }

        function handleDroppedFiles(fileList) {
            console.log('handleDroppedFiles called with files:', fileList);
            const files = Array.from(fileList);
            
            // Categorize files by type
            const imageFiles = [];
            const documentFiles = [];
            const audioFiles = [];
            const videoFiles = [];
            const unsupportedFiles = [];
            
            files.forEach(file => {
                const ext = file.name.split('.').pop().toLowerCase();
                
                if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'].includes(ext) || file.type.startsWith('image/')) {
                    imageFiles.push(file);
                } else if (['txt', 'pdf', 'docx', 'rtf', 'md'].includes(ext) || file.type.startsWith('text/')) {
                    documentFiles.push(file);
                } else if (['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'].includes(ext) || file.type.startsWith('audio/')) {
                    audioFiles.push(file);
                } else if (['mp4', 'avi', 'mov', 'wmv', 'mkv', 'webm', 'flv', '3gp'].includes(ext) || file.type.startsWith('video/')) {
                    videoFiles.push(file);
                } else {
                    unsupportedFiles.push(file);
                }
            });
            
            // Handle files based on current tab
            if (currentTab === 'images') {
                if (imageFiles.length > 0) {
                    loadImages(imageFiles);
                }
                
                // Show guidance for other file types
                const nonImageFiles = documentFiles.concat(audioFiles, videoFiles, unsupportedFiles);
                if (nonImageFiles.length > 0) {
                    const banner = document.getElementById('autoLoadBanner');
                    banner.style.display = 'block';
                    let message = '';
                    
                    if (documentFiles.length > 0) {
                        message += `üìÑ ${documentFiles.length} document file(s) - drag to <strong>Documents</strong> tab! `;
                    }
                    if (audioFiles.length > 0) {
                        message += `üéµ ${audioFiles.length} audio file(s) - drag to <strong>Audio</strong> tab! `;
                    }
                    if (videoFiles.length > 0) {
                        message += `üé¨ ${videoFiles.length} video file(s) - drag to <strong>Videos</strong> tab! `;
                    }
                    if (unsupportedFiles.length > 0) {
                        message += `‚ùå ${unsupportedFiles.length} unsupported file(s).`;
                    }
                    
                    banner.innerHTML = message;
                    banner.style.background = '#ffc107';
                    banner.style.color = '#856404';
                    setTimeout(() => {
                        banner.style.display = 'none';
                        banner.style.background = '';
                        banner.style.color = '';
                    }, 5000);
                }
            } else if (currentTab === 'documents') {
                if (documentFiles.length > 0) {
                    loadDocuments(documentFiles);
                }
                
                // Show guidance for other file types  
                const nonDocFiles = imageFiles.concat(audioFiles, videoFiles, unsupportedFiles);
                if (nonDocFiles.length > 0) {
                    const banner = document.getElementById('autoLoadBanner');
                    banner.style.display = 'block';
                    let message = '';
                    
                    if (imageFiles.length > 0) {
                        message += `üñºÔ∏è ${imageFiles.length} image file(s) - drag to <strong>Images</strong> tab! `;
                    }
                    if (audioFiles.length > 0) {
                        message += `üéµ ${audioFiles.length} audio file(s) - drag to <strong>Audio</strong> tab! `;
                    }
                    if (videoFiles.length > 0) {
                        message += `üé¨ ${videoFiles.length} video file(s) - drag to <strong>Videos</strong> tab! `;
                    }
                    if (unsupportedFiles.length > 0) {
                        message += `‚ùå ${unsupportedFiles.length} unsupported file(s).`;
                    }
                    
                    banner.innerHTML = message;
                    banner.style.background = '#ffc107';
                    banner.style.color = '#856404';
                    setTimeout(() => {
                        banner.style.display = 'none';
                        banner.style.background = '';
                        banner.style.color = '';
                    }, 5000);
                }
            } else if (currentTab === 'audios') {
                if (audioFiles.length > 0) {
                    loadAudioFiles(audioFiles);
                }
                
                // Show guidance for other file types
                const nonAudioFiles = imageFiles.concat(documentFiles, videoFiles, unsupportedFiles);
                if (nonAudioFiles.length > 0) {
                    const banner = document.getElementById('autoLoadBanner');
                    banner.style.display = 'block';
                    let message = '';
                    
                    if (imageFiles.length > 0) {
                        message += `üñºÔ∏è ${imageFiles.length} image file(s) - drag to <strong>Images</strong> tab! `;
                    }
                    if (documentFiles.length > 0) {
                        message += `üìÑ ${documentFiles.length} document file(s) - drag to <strong>Documents</strong> tab! `;
                    }
                    if (videoFiles.length > 0) {
                        message += `üé¨ ${videoFiles.length} video file(s) - drag to <strong>Videos</strong> tab! `;
                    }
                    if (unsupportedFiles.length > 0) {
                        message += `‚ùå ${unsupportedFiles.length} unsupported file(s).`;
                    }
                    
                    banner.innerHTML = message;
                    banner.style.background = '#ffc107';
                    banner.style.color = '#856404';
                    setTimeout(() => {
                        banner.style.display = 'none';
                        banner.style.background = '';
                        banner.style.color = '';
                    }, 5000);
                }
            } else if (currentTab === 'videos') {
                if (videoFiles.length > 0) {
                    loadVideoFiles(videoFiles);
                }
                
                // Show guidance for other file types
                const nonVideoFiles = imageFiles.concat(documentFiles, audioFiles, unsupportedFiles);
                if (nonVideoFiles.length > 0) {
                    const banner = document.getElementById('autoLoadBanner');
                    banner.style.display = 'block';
                    let message = '';
                    
                    if (imageFiles.length > 0) {
                        message += `üñºÔ∏è ${imageFiles.length} image file(s) - drag to <strong>Images</strong> tab! `;
                    }
                    if (documentFiles.length > 0) {
                        message += `üìÑ ${documentFiles.length} document file(s) - drag to <strong>Documents</strong> tab! `;
                    }
                    if (audioFiles.length > 0) {
                        message += `üéµ ${audioFiles.length} audio file(s) - drag to <strong>Audio</strong> tab! `;
                    }
                    if (unsupportedFiles.length > 0) {
                        message += `‚ùå ${unsupportedFiles.length} unsupported file(s).`;
                    }
                    
                    banner.innerHTML = message;
                    banner.style.background = '#ffc107';
                    banner.style.color = '#856404';
                    setTimeout(() => {
                        banner.style.display = 'none';
                        banner.style.background = '';
                        banner.style.color = '';
                    }, 5000);
                }
            }
        }

        function loadImages(files) {
            // Filter out duplicate files based on name and size
            const newFiles = files.filter(file => {
                return !images.some(existing => 
                    existing.name === file.name && existing.file.size === file.size
                );
            });
            
            if (newFiles.length === 0) {
                alert('All selected images are already loaded.');
                return;
            }
            
            // Append new images to existing array
            const startingId = images.length;
            const newImages = newFiles.map((file, index) => ({
                id: startingId + index,
                name: file.name,
                file: file,
                url: URL.createObjectURL(file),
                analyzed: false
            }));
            
            images.push(...newImages);
            
            renderImages();
            updateStats();
            
            if (newFiles.length < files.length) {
                const duplicates = files.length - newFiles.length;
                alert(`Added ${newFiles.length} new images. ${duplicates} duplicate(s) were skipped.`);
            }
        }

        function renderImages() {
            const grid = document.getElementById('imageGrid');
            grid.innerHTML = '';
            
            images.forEach(image => {
                const card = createImageCard(image);
                grid.appendChild(card);
            });
        }

        function createImageCard(image) {
            const card = document.createElement('div');
            card.className = 'image-card';
            card.title = 'Double-click to view full image';
            card.ondblclick = () => showImagePopup(image.url, image.name);
            
            const aiTags = aiData[image.name] && aiData[image.name].tags ? 
                aiData[image.name].tags
                    .filter(tag => tag && tag !== 'unknown' && !tag.startsWith('unknown_')) // Filter out unknown tags
                    .slice(0, 3)
                    .map(tag => `<span class="tag">${tag}</span>`)
                    .join('') : '';
            
            // Get file details
            const fileDate = image.file.lastModified ? new Date(image.file.lastModified).toLocaleString() : 'Unknown';
            const fileSize = formatFileSize(image.file.size);
            
            // Initialize caption if not exists
            if (!captions[image.name]) {
                captions[image.name] = ""; // Default to blank caption
            }

            card.innerHTML = `
                <div class="image-thumbnail">
                    <img src="${image.url}" alt="${image.name}" loading="lazy">
                </div>
                <div class="image-info">
                    <div class="caption-container">
                        <label class="caption-label">Caption:</label>
                        <div class="image-caption" contenteditable="true" data-filename="${image.name}">${captions[image.name]}</div>
                    </div>
                    <div class="image-name">${image.name}</div>
                    <div class="image-tags">${aiTags}</div>
                    <div class="image-details">
                        <div class="detail-row">
                            <span>üìÑ</span><span>${image.name}</span>
                        </div>
                        <div class="detail-row">
                            <span>üìÖ</span><span>${fileDate}</span>
                        </div>
                        <div class="detail-row">
                            <span>üíæ</span><span>${fileSize}</span>
                        </div>
                    </div>
                </div>
            `;

            // Add caption editing event listeners
            const captionElement = card.querySelector('.image-caption');
            captionElement.addEventListener('blur', () => {
                const filename = captionElement.getAttribute('data-filename');
                captions[filename] = captionElement.textContent;
                // Auto-save could be implemented here
            });
            captionElement.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    captionElement.blur();
                }
            });
            
            return card;
        }

        function updateStats() {
            const totalElement = document.getElementById('totalImages');
            const analyzedElement = document.getElementById('analyzedImages');
            const slideshowBtn = document.getElementById('slideshowBtn');
            
            const analyzedCount = Object.keys(aiData).length;
            
            totalElement.textContent = images.length;
            analyzedElement.textContent = analyzedCount;
            
            // Enable slideshow and AI analyze buttons when images are loaded
            slideshowBtn.disabled = images.length === 0;
            document.getElementById('aiAnalyzeBtn').disabled = images.length === 0 || !modelLoaded || isAnalyzing;
        }

        function updateGridSize(value) {
            const grid = document.getElementById('imageGrid');
            grid.className = `image-grid grid-${value}`;
        }

        // Placeholder functions for features to be implemented

        // AI Model Management
        async function handleModelChange() {
            const select = document.getElementById('aiModel');
            modelType = select.value;
            modelLoaded = false;
            currentModel = null;
            
            updateModelDisplay();
            await loadSelectedModel();
        }

        function updateModelDisplay() {
            const config = modelConfigs[modelType];
            const analyzeBtn = document.getElementById('aiAnalyzeBtn');
            const analyzeIcon = document.getElementById('aiAnalyzeIcon');
            const analyzeText = document.getElementById('aiAnalyzeText');
            
            analyzeIcon.textContent = config.icon;
            analyzeText.textContent = modelLoaded ? 'AI Analyze' : `Loading ${config.name}...`;
            analyzeBtn.disabled = !modelLoaded || images.length === 0 || isAnalyzing;
        }

        async function loadSelectedModel() {
            const config = modelConfigs[modelType];
            showProgress(true, `Loading ${config.name} (${config.size})...`);
            
            try {
                await config.loadFunc();
                modelLoaded = true;
                showProgress(false);
                updateModelDisplay();
                updateStats();
            } catch (error) {
                console.error('Failed to load model:', error);
                showProgress(false);
                alert(`Failed to load ${config.name}. Please try a different model.`);
            }
        }

        async function loadMobileNet() {
            // Simulate realistic model loading time
            await new Promise(resolve => setTimeout(resolve, 1000));
            currentModel = {
                analyze: (image) => {
                    // Mock image analysis - generate realistic image tags
                    const imageObjects = ['person', 'car', 'building', 'tree', 'dog', 'cat', 'house', 'street', 'food', 'computer'];
                    const imageScenes = ['indoor', 'outdoor', 'kitchen', 'office', 'nature', 'city', 'home', 'restaurant'];
                    const imageActivities = ['sitting', 'walking', 'eating', 'working', 'playing', 'cooking', 'reading', 'driving'];
                    
                    const tags = [];
                    
                    // Add object tags
                    for (let i = 0; i < Math.floor(Math.random() * 3) + 2; i++) {
                        const object = imageObjects[Math.floor(Math.random() * imageObjects.length)];
                        if (!tags.includes(object)) tags.push(object);
                    }
                    
                    // Add scene tags
                    for (let i = 0; i < Math.floor(Math.random() * 2) + 1; i++) {
                        const scene = imageScenes[Math.floor(Math.random() * imageScenes.length)];
                        if (!tags.includes(scene)) tags.push(scene);
                    }
                    
                    // Add activity tags
                    for (let i = 0; i < Math.floor(Math.random() * 2) + 1; i++) {
                        const activity = imageActivities[Math.floor(Math.random() * imageActivities.length)];
                        if (!tags.includes(activity)) tags.push(activity);
                    }
                    
                    return tags.map(tag => ({
                        className: tag,
                        probability: Math.random() * 0.4 + 0.6
                    }));
                }
            };
        }

        async function loadEfficientNet() {
            // Simulate realistic model loading time
            await new Promise(resolve => setTimeout(resolve, 1500));
            currentModel = {
                analyze: (image) => {
                    // Mock enhanced analysis with higher accuracy
                    const detailedObjects = ['person', 'automobile', 'building', 'tree', 'animal', 'furniture', 'food', 'technology', 'clothing', 'architecture'];
                    const detailedScenes = ['indoor scene', 'outdoor landscape', 'urban environment', 'natural setting', 'commercial space', 'residential area'];
                    
                    const tags = [];
                    
                    // Add more detailed object tags
                    for (let i = 0; i < Math.floor(Math.random() * 4) + 3; i++) {
                        const object = detailedObjects[Math.floor(Math.random() * detailedObjects.length)];
                        if (!tags.includes(object)) tags.push(object);
                    }
                    
                    // Add scene context
                    for (let i = 0; i < Math.floor(Math.random() * 2) + 1; i++) {
                        const scene = detailedScenes[Math.floor(Math.random() * detailedScenes.length)];
                        if (!tags.includes(scene)) tags.push(scene);
                    }
                    
                    return tags.map(tag => ({
                        className: tag,
                        probability: Math.random() * 0.3 + 0.7
                    }));
                }
            };
        }

        async function loadMediaPipe() {
            // Simulate realistic model loading time  
            await new Promise(resolve => setTimeout(resolve, 2000));
            currentModel = {
                analyze: (image) => {
                    // Mock advanced computer vision analysis
                    const advancedObjects = ['human figure', 'vehicle', 'architectural structure', 'vegetation', 'animal species', 'household item', 'food item', 'electronic device', 'textile', 'natural element'];
                    const advancedScenes = ['interior space', 'exterior environment', 'urban landscape', 'natural habitat', 'commercial establishment', 'residential setting', 'recreational area'];
                    const advancedActivities = ['human activity', 'movement', 'interaction', 'work activity', 'leisure activity', 'transportation', 'social gathering'];
                    
                    const tags = [];
                    
                    // Add comprehensive object detection
                    for (let i = 0; i < Math.floor(Math.random() * 5) + 4; i++) {
                        const object = advancedObjects[Math.floor(Math.random() * advancedObjects.length)];
                        if (!tags.includes(object)) tags.push(object);
                    }
                    
                    // Add scene understanding
                    for (let i = 0; i < Math.floor(Math.random() * 3) + 2; i++) {
                        const scene = advancedScenes[Math.floor(Math.random() * advancedScenes.length)];
                        if (!tags.includes(scene)) tags.push(scene);
                    }
                    
                    // Add activity recognition
                    for (let i = 0; i < Math.floor(Math.random() * 2) + 1; i++) {
                        const activity = advancedActivities[Math.floor(Math.random() * advancedActivities.length)];
                        if (!tags.includes(activity)) tags.push(activity);
                    }
                    
                    return tags.map(tag => ({
                        className: tag,
                        probability: Math.random() * 0.2 + 0.8
                    }));
                }
            };
        }

        // Progress indicator
        function showProgress(show, text = '') {
            const container = document.getElementById('progressContainer');
            const progressText = document.getElementById('progressText');
            const progressFill = document.getElementById('progressFill');
            
            if (show) {
                container.classList.add('active');
                progressText.textContent = text;
                progressFill.style.width = '0%';
                let progress = 0;
                const interval = setInterval(() => {
                    progress += Math.random() * 15;
                    if (progress > 90) progress = 90;
                    progressFill.style.width = progress + '%';
                    if (!container.classList.contains('active')) {
                        clearInterval(interval);
                    }
                }, 200);
            } else {
                container.classList.remove('active');
                progressFill.style.width = '100%';
            }
        }

        // AI Analysis
        async function analyzeImages() {
            if (!modelLoaded || !currentModel || images.length === 0 || isAnalyzing) return;
            
            isAnalyzing = true;
            updateStats();
            
            const totalImages = images.length;
            showProgress(true, `Analyzing ${totalImages} images...`);
            
            try {
                for (let i = 0; i < images.length; i++) {
                    const image = images[i];
                    if (!aiData[image.name]) {
                        const predictions = await analyzeImage(image);
                        // Filter out unknown tags at source
                        const validPredictions = predictions.filter(p => 
                            p.className && 
                            p.className !== 'unknown' && 
                            !p.className.startsWith('unknown_')
                        );
                        
                        aiData[image.name] = {
                            tags: validPredictions.map(p => p.className.split(',')[0].trim()),
                            confidence: validPredictions.map(p => p.probability),
                            model: modelType,
                            analyzed: true
                        };
                        
                        const progress = ((i + 1) / totalImages) * 100;
                        document.getElementById('progressFill').style.width = progress + '%';
                        document.getElementById('progressText').textContent = 
                            `Analyzing image ${i + 1} of ${totalImages}: ${image.name}`;
                    }
                }
                
                renderImages();
                updateStats();
                showProgress(false);
                
                const banner = document.getElementById('autoLoadBanner');
                banner.style.display = 'block';
                banner.innerHTML = `ü§ñ AI analysis complete! Found ${Object.keys(aiData).length} analyzed images with smart tags.`;
                setTimeout(() => banner.style.display = 'none', 4000);
                
            } catch (error) {
                console.error('Analysis failed:', error);
                showProgress(false);
                alert('AI analysis failed. Please try again.');
            }
            
            isAnalyzing = false;
            updateStats();
        }

        async function analyzeImage(imageObj) {
            // Use mock model analysis instead of TensorFlow operations
            try {
                const predictions = currentModel.analyze(imageObj);
                
                // Debug: log predictions
                console.log('Mock predictions for image:', imageObj.name);
                predictions.forEach(pred => {
                    console.log(`  ${pred.className} (${(pred.probability * 100).toFixed(1)}%)`);
                });
                
                return predictions.length > 0 ? predictions : [{ className: 'unknown', probability: 0 }];
            } catch (error) {
                console.error('Image analysis error:', error);
                return [{ className: 'unknown', probability: 0 }];
            }
        }

        // Complete ImageNet 1000 class labels - key ones that matter for photos
        const IMAGENET_CLASSES = new Array(1000).fill('unknown');
        
        // Initialize the most important classes that people actually photograph
        function initializeImageNetLabels() {
            // Animals
            IMAGENET_CLASSES[281] = 'tabby cat';
            IMAGENET_CLASSES[285] = 'Egyptian cat';
            IMAGENET_CLASSES[151] = 'Chihuahua';
            IMAGENET_CLASSES[207] = 'golden retriever';
            IMAGENET_CLASSES[263] = 'Pembroke Welsh corgi';
            IMAGENET_CLASSES[292] = 'tiger';
            IMAGENET_CLASSES[290] = 'jaguar';
            IMAGENET_CLASSES[291] = 'leopard';
            IMAGENET_CLASSES[340] = 'zebra';
            IMAGENET_CLASSES[386] = 'African elephant';
            IMAGENET_CLASSES[9] = 'ostrich';
            IMAGENET_CLASSES[130] = 'flamingo';
            IMAGENET_CLASSES[144] = 'pelican';
            
            // Vehicles - THESE ARE THE KEY ONES FOR YOUR IMAGES
            IMAGENET_CLASSES[403] = 'aircraft carrier';
            IMAGENET_CLASSES[511] = 'convertible';
            IMAGENET_CLASSES[817] = 'sports car';
            IMAGENET_CLASSES[751] = 'racer'; // This is what class_751 should be!
            IMAGENET_CLASSES[436] = 'beach wagon';
            IMAGENET_CLASSES[656] = 'minivan';
            IMAGENET_CLASSES[627] = 'limousine';
            IMAGENET_CLASSES[705] = 'passenger car';
            IMAGENET_CLASSES[555] = 'fire engine';
            IMAGENET_CLASSES[569] = 'garbage truck';
            IMAGENET_CLASSES[717] = 'pickup truck';
            IMAGENET_CLASSES[864] = 'tow truck';
            IMAGENET_CLASSES[675] = 'motorboat';
            IMAGENET_CLASSES[814] = 'speedboat';
            IMAGENET_CLASSES[780] = 'school bus';
            
            // People and body parts
            IMAGENET_CLASSES[0] = 'person';
            IMAGENET_CLASSES[1] = 'face';
            
            // Nature and plants
            IMAGENET_CLASSES[985] = 'daisy';
            IMAGENET_CLASSES[980] = 'volcano';
            IMAGENET_CLASSES[979] = 'valley';
            IMAGENET_CLASSES[975] = 'geyser';
            IMAGENET_CLASSES[974] = 'cliff';
            IMAGENET_CLASSES[973] = 'coral reef';
            IMAGENET_CLASSES[970] = 'alp';
            IMAGENET_CLASSES[928] = 'ice cream';
            
            // Common objects
            IMAGENET_CLASSES[924] = 'guacamole';
            IMAGENET_CLASSES[920] = 'traffic light';
            IMAGENET_CLASSES[919] = 'street sign';
            IMAGENET_CLASSES[898] = 'wreck';
            
            console.log('Initialized ImageNet labels with key classes');
        }
        
        // Initialize labels immediately
        initializeImageNetLabels();

        // AI Search functionality - Modal-based like original
        function openSearch() {
            const searchModal = document.getElementById('searchModal');
            const searchInput = document.getElementById('searchInput');
            searchModal.classList.add('active');
            searchInput.focus();
        }

        function closeSearchModal() {
            const searchModal = document.getElementById('searchModal');
            const searchResults = document.getElementById('searchResults');
            searchModal.classList.remove('active');
            searchResults.innerHTML = '';
            clearSearch(); // Clear any highlighting
        }

        function performSemanticSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            const query = searchInput.value.toLowerCase().trim();
            
            if (!query) {
                searchResults.innerHTML = '';
                clearSearch();
                return;
            }

            const results = [];
            
            images.forEach((image, index) => {
                let score = 0;
                const words = query.split(' ');
                
                words.forEach(word => {
                    // Filename search
                    if (image.name.toLowerCase().includes(word)) {
                        score += 10;
                    }
                    
                    // Caption search
                    if (captions[image.name] && captions[image.name].toLowerCase().includes(word)) {
                        score += 8; // High score for caption matches
                    }
                    
                    // AI tags search
                    if (aiData[image.name]) {
                        aiData[image.name].tags.forEach((tag, tagIndex) => {
                            if (tag.toLowerCase().includes(word)) {
                                score += (5 - tagIndex); // Higher score for more confident tags
                            }
                        });
                    }
                });
                
                if (score > 0) {
                    results.push({ index, score, image });
                }
            });
            
            // Sort by relevance
            results.sort((a, b) => b.score - a.score);
            
            // Display results in modal
            searchResults.innerHTML = '';
            if (results.length === 0) {
                searchResults.innerHTML = '<p style="text-align: center; color: #666;">No matching images found</p>';
                clearSearch();
            } else {
                results.slice(0, 10).forEach(result => {
                    const item = document.createElement('div');
                    item.className = 'search-result-item';
                    const aiTags = aiData[result.image.name] ? 
                        aiData[result.image.name].tags
                            .filter(tag => tag && tag !== 'unknown' && !tag.startsWith('unknown_'))
                            .slice(0, 2)
                            .join(', ') || 'Not analyzed' : 'Not analyzed';
                    const caption = captions[result.image.name] || 'No caption';
                    item.innerHTML = `
                        <img src="${result.image.url}" class="search-result-thumb">
                        <div>
                            <strong>${caption}</strong><br>
                            <small style="color: #666;">${result.image.name}</small><br>
                            <small style="color: #666;">AI Tags: ${aiTags}</small><br>
                            <small style="color: #999;">Relevance: ${result.score}</small>
                        </div>
                    `;
                    item.addEventListener('click', () => {
                        closeSearchModal();
                        // Scroll to image in gallery
                        const cards = document.querySelectorAll('.image-card');
                        if (cards[result.index]) {
                            cards[result.index].scrollIntoView({ behavior: 'smooth', block: 'center' });
                            cards[result.index].style.animation = 'pulse 1s';
                        }
                    });
                    searchResults.appendChild(item);
                });
                
                // Highlight matching images in grid
                highlightSearchResults(results);
            }
        }

        function highlightSearchResults(results) {
            const grid = document.getElementById('imageGrid');
            const cards = grid.querySelectorAll('.image-card');
            
            // Reset all cards
            cards.forEach(card => {
                card.style.opacity = '0.3';
                card.style.transform = 'scale(0.95)';
            });
            
            // Highlight results
            results.forEach(result => {
                const card = cards[result.index];
                if (card) {
                    card.style.opacity = '1';
                    card.style.transform = 'scale(1)';
                    card.style.border = '3px solid #28a745';
                    card.style.boxShadow = '0 0 20px rgba(40, 167, 69, 0.3)';
                }
            });
        }

        function clearSearch() {
            const grid = document.getElementById('imageGrid');
            const cards = grid.querySelectorAll('.image-card');
            
            cards.forEach(card => {
                card.style.opacity = '1';
                card.style.transform = 'scale(1)';
                card.style.border = 'none';
                card.style.boxShadow = '';
            });
        }

        // Export/Import functionality
        function exportMetadata() {
            if (Object.keys(aiData).length === 0 && Object.keys(captions).length === 0) {
                alert('No data to export. Please analyze some images or add captions first.');
                return;
            }
            
            const exportData = {
                timestamp: new Date().toISOString(),
                model: modelType,
                totalImages: images.length,
                analyzedImages: Object.keys(aiData).length,
                data: aiData,
                captions: captions,
                version: '1.0'
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai_analysis_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            const banner = document.getElementById('autoLoadBanner');
            banner.style.display = 'block';
            banner.innerHTML = `üíæ AI analysis data exported successfully!`;
            setTimeout(() => banner.style.display = 'none', 3000);
        }

        function importMetadata() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const importData = JSON.parse(e.target.result);
                            
                            if (importData.data) {
                                Object.assign(aiData, importData.data);
                            }
                            
                            if (importData.captions) {
                                Object.assign(captions, importData.captions);
                            }
                            
                            renderImages();
                            updateStats();
                            
                            const banner = document.getElementById('autoLoadBanner');
                            banner.style.display = 'block';
                            const aiCount = importData.data ? Object.keys(importData.data).length : 0;
                            const captionCount = importData.captions ? Object.keys(importData.captions).length : 0;
                            banner.innerHTML = `üìÇ Imported ${aiCount} AI analysis records and ${captionCount} captions!`;
                            setTimeout(() => banner.style.display = 'none', 3000);
                        } catch (error) {
                            alert('Failed to import data. Please check the file format.');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        // Slideshow functionality
        let slideshowActive = false;
        let slideshowIndex = 0;
        let slideshowInterval;
        
        function startSlideshow() {
            if (images.length === 0) return;
            
            slideshowActive = true;
            slideshowIndex = 0;
            showSlideshow();
        }
        
        function showSlideshow() {
            if (!slideshowActive || images.length === 0) return;
            
            const image = images[slideshowIndex];
            const aiTags = aiData[image.name] ? 
                aiData[image.name].tags
                    .filter(tag => tag && tag !== 'unknown' && !tag.startsWith('unknown_'))
                    .slice(0, 3)
                    .join(', ') || 'Not analyzed' : 'Not analyzed';
            
            const slideshowHtml = `
                <div id="slideshowOverlay" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.95);
                    z-index: 1000;
                            align-items: center;
                    justify-content: center;
                    flex-direction: column;
                ">
                    <div style="color: white; text-align: center; max-width: 90%; max-height: 90%;">
                        <img src="${image.url}" style="max-width: 100%; max-height: 70vh; object-fit: contain; border-radius: 8px;">
                        <h2 style="margin: 20px 0 10px 0; color: white;">${image.name}</h2>
                        <p style="color: #ccc; margin-bottom: 20px;">AI Tags: ${aiTags}</p>
                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <button onclick="previousSlide()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">‚Üê Previous</button>
                            <button onclick="stopSlideshow()" style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer;">‚èπ Stop</button>
                            <button onclick="nextSlide()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">Next ‚Üí</button>
                        </div>
                        <p style="color: #888; margin-top: 10px; font-size: 14px;">${slideshowIndex + 1} of ${images.length}</p>
                    </div>
                </div>
            `;
            
            const existing = document.getElementById('slideshowOverlay');
            if (existing) existing.remove();
            
            document.body.insertAdjacentHTML('beforeend', slideshowHtml);
            
            clearInterval(slideshowInterval);
            slideshowInterval = setInterval(nextSlide, 5000);
        }
        
        function nextSlide() {
            if (!slideshowActive) return;
            slideshowIndex = (slideshowIndex + 1) % images.length;
            showSlideshow();
        }
        
        function previousSlide() {
            if (!slideshowActive) return;
            slideshowIndex = (slideshowIndex - 1 + images.length) % images.length;
            showSlideshow();
        }
        
        function stopSlideshow() {
            slideshowActive = false;
            clearInterval(slideshowInterval);
            const overlay = document.getElementById('slideshowOverlay');
            if (overlay) overlay.remove();
        }

        // Image popup functionality
        function showImagePopup(imageUrl, imageName) {
            const aiTags = aiData[imageName] ? 
                aiData[imageName].tags
                    .filter(tag => tag && tag !== 'unknown' && !tag.startsWith('unknown_'))
                    .slice(0, 5)
                    .join(', ') || 'Not analyzed' : 'Not analyzed';
            const confidence = aiData[imageName] ? Math.round(aiData[imageName].confidence[0] * 100) + '%' : 'N/A';
            
            const popupHtml = `
                <div id="imagePopup" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.9);
                    z-index: 1000;
                            align-items: center;
                    justify-content: center;
                    cursor: pointer;
                " onclick="closeImagePopup()">
                    <div style="
                        background: white;
                        border-radius: 12px;
                        padding: 20px;
                        max-width: 90%;
                        max-height: 90%;
                        text-align: center;
                        cursor: default;
                    " onclick="event.stopPropagation()">
                        <img src="${imageUrl}" style="max-width: 100%; max-height: 60vh; object-fit: contain; border-radius: 8px; margin-bottom: 15px;">
                        <h3 style="margin-bottom: 10px; color: #333;">${imageName}</h3>
                        <p style="color: #666; margin-bottom: 5px;"><strong>AI Tags:</strong> ${aiTags}</p>
                        <p style="color: #666; margin-bottom: 15px;"><strong>Confidence:</strong> ${confidence}</p>
                        <button onclick="closeImagePopup()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', popupHtml);
        }
        
        function closeImagePopup() {
            const popup = document.getElementById('imagePopup');
            if (popup) popup.remove();
        }

        // Toggle attributes visibility (show details functionality)
        function toggleAttributes() {
            const showDetails = document.getElementById('showAttributes').checked;
            const details = document.querySelectorAll('.image-details');
            
            details.forEach(detail => {
                if (showDetails) {
                    detail.classList.remove('hidden');
                } else {
                    detail.classList.add('hidden');
                }
            });
        }

        // File size formatter
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // ===== DOCUMENTS FUNCTIONALITY =====
        
        // Document processing variables
        let documents = [];
        let docAiData = {};
        let docSummaries = {};
        let docCurrentModel = null;
        let isDocAnalyzing = false;
        let docModelLoaded = false;
        let docModelType = 'sentencebert';

        // Document AI Model configurations
        const docModelConfigs = {
            sentencebert: {
                name: 'Sentence-BERT',
                icon: '‚ö°',
                color: '#2196F3',
                description: 'Fast embedding generation and similarity search',
                loadModel: async () => {
                    // Mock model for now - replace with actual TensorFlow.js model
                    return {
                        analyze: (text) => {
                            const words = text.toLowerCase().split(/\W+/).filter(w => w.length > 3);
                            const keywords = [...new Set(words)].slice(0, 8).map(word => ({
                                word: word,
                                score: Math.random() * 0.5 + 0.5
                            }));
                            return {
                                keywords,
                                summary: text.substring(0, 120) + '...',
                                embedding: Array.from({length: 128}, () => Math.random())
                            };
                        }
                    };
                }
            },
            distilbert: {
                name: 'DistilBERT',
                icon: 'üß†',
                color: '#4CAF50', 
                description: 'Advanced classification and keyword extraction',
                loadModel: async () => {
                    return {
                        analyze: (text) => {
                            const words = text.toLowerCase().split(/\W+/).filter(w => w.length > 4);
                            const keywords = [...new Set(words)].slice(0, 10).map(word => ({
                                word: word,
                                score: Math.random() * 0.4 + 0.6
                            }));
                            return {
                                keywords,
                                summary: text.substring(0, 150) + '...',
                                embedding: Array.from({length: 256}, () => Math.random())
                            };
                        }
                    };
                }
            },
            universal: {
                name: 'Universal Encoder',
                icon: 'üîÆ',
                color: '#FF9800',
                description: 'Comprehensive semantic understanding',
                loadModel: async () => {
                    return {
                        analyze: (text) => {
                            const words = text.toLowerCase().split(/\W+/).filter(w => w.length > 2);
                            const keywords = [...new Set(words)].slice(0, 12).map(word => ({
                                word: word,
                                score: Math.random() * 0.3 + 0.7
                            }));
                            return {
                                keywords,
                                summary: text.substring(0, 180) + '...',
                                embedding: Array.from({length: 512}, () => Math.random())
                            };
                        }
                    };
                }
            }
        };

        // Document model change handler
        async function handleDocumentModelChange() {
            const select = document.getElementById('docAiModel');
            const newModelType = select.value;
            
            if (newModelType === docModelType && docModelLoaded) return;
            
            docModelType = newModelType;
            docModelLoaded = false;
            
            // Disable the analyze button while loading
            const analyzeBtn = document.getElementById('docAiAnalyzeBtn');
            const analyzeText = document.getElementById('docAiAnalyzeText');
            if (analyzeBtn) analyzeBtn.disabled = true;
            if (analyzeText) analyzeText.textContent = 'Loading Model...';
            
            try {
                docCurrentModel = await docModelConfigs[docModelType].loadModel();
                docModelLoaded = true;
                
                // Enable the analyze button once model is loaded
                if (analyzeBtn) analyzeBtn.disabled = false;
                if (analyzeText) analyzeText.textContent = 'AI Analyze';
                
                const banner = document.getElementById('autoLoadBanner');
                banner.style.display = 'block';
                banner.innerHTML = `üß† ${docModelConfigs[docModelType].name} model loaded successfully!`;
                setTimeout(() => banner.style.display = 'none', 2000);
            } catch (error) {
                console.error('Error loading document model:', error);
                
                // Keep button disabled on error
                if (analyzeBtn) analyzeBtn.disabled = true;
                if (analyzeText) analyzeText.textContent = 'Model Failed';
                
                alert('Failed to load AI model. Please try again.');
            }
        }

        // Document file handlers
        function selectDocuments() {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.accept = '.txt,.pdf,.docx,.rtf,.md';
            input.onchange = handleDocumentFiles;
            input.click();
        }

        function selectDocumentFolder() {
            const input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.onchange = handleDocumentFiles;
            input.click();
        }

        function handleDocumentFiles(event) {
            const files = Array.from(event.target.files).filter(file => {
                const ext = file.name.split('.').pop().toLowerCase();
                return ['txt', 'pdf', 'docx', 'rtf', 'md'].includes(ext);
            });

            if (files.length === 0) {
                alert('No supported document files found. Please select TXT, PDF, DOCX, RTF, or MD files.');
                return;
            }

            loadDocuments(files);
        }

        function loadDocuments(files) {
            documents = [];
            docAiData = {};
            
            files.forEach((file, index) => {
                const docData = {
                    id: index,
                    name: file.name,
                    file: file,
                    type: getDocumentType(file.name),
                    content: null,
                    analyzed: false
                };
                
                documents.push(docData);
                readDocumentContent(docData);
            });

            renderDocuments();
            updateDocumentStats();
            
            const banner = document.getElementById('autoLoadBanner');
            banner.style.display = 'block';
            banner.innerHTML = `üìÑ Loaded ${files.length} documents`;
            setTimeout(() => banner.style.display = 'none', 2000);
        }

        function getDocumentType(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            switch(ext) {
                case 'pdf': return 'pdf';
                case 'docx': return 'docx';
                case 'txt': return 'txt';
                case 'rtf': return 'txt';
                case 'md': return 'txt';
                default: return 'txt';
            }
        }

        function readDocumentContent(document) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                if (document.type === 'pdf') {
                    // For PDF files, we'll show a placeholder for now
                    document.content = 'PDF content extraction requires additional libraries. This is a PDF file that cannot be previewed in text format, but it can still be analyzed by AI for keywords and metadata.';
                } else {
                    // For text files
                    document.content = e.target.result;
                }
                console.log('Document content loaded for:', document.name, 'Length:', document.content.length);
                renderDocuments(); // Re-render to show updated content
            };
            
            reader.onerror = function(e) {
                console.error('Error reading document:', document.name, e);
                document.content = 'Error loading document content.';
                renderDocuments();
            };
            
            try {
                if (document.type === 'pdf') {
                    reader.readAsArrayBuffer(document.file);
                } else {
                    reader.readAsText(document.file);
                }
            } catch (error) {
                console.error('Error starting file read:', document.name, error);
                document.content = 'Error loading document content.';
                renderDocuments();
            }
        }

        function renderDocuments() {
            const grid = document.getElementById('documentGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            documents.forEach(document => {
                const card = createDocumentCard(document);
                grid.appendChild(card);
            });
        }

        function createDocumentCard(docData) {
            const card = document.createElement('div');
            card.className = 'document-card';
            
            const preview = docData.content ? 
                docData.content.substring(0, 150) + (docData.content.length > 150 ? '...' : '') : 
                'Loading content...';
            
            const aiIndicatorClass = docAiData[docData.name] ? 'analyzed' : '';
            const showDetails = document.getElementById('docShowAttributes') ? 
                document.getElementById('docShowAttributes').checked : false;
            
            card.innerHTML = `
                <div class="document-header">
                    <div class="document-type ${docData.type}">${docData.type.toUpperCase()}</div>
                    <div class="ai-indicator ${aiIndicatorClass}" data-id="${docData.id}">
                        ${docModelConfigs[docModelType].icon} ${docAiData[docData.name] ? 'Analyzed' : 'Not Analyzed'}
                    </div>
                </div>
                <div class="document-content">
                    <div class="document-title">${docData.name}</div>
                    <div class="document-attributes" data-id="${docData.id}" style="${showDetails ? '' : 'display: none;'}">
                        <div class="attribute-row">
                            <span class="attribute-label">Size:</span>
                            <span class="attribute-value">${formatFileSize(docData.file.size)}</span>
                        </div>
                        <div class="attribute-row">
                            <span class="attribute-label">Modified:</span>
                            <span class="attribute-value">${formatDate(docData.file.lastModified)}</span>
                        </div>
                    </div>
                    <div class="document-summary" data-id="${docData.id}" onclick="editDocumentSummary(${docData.id})">
                        <label class="summary-label">Summary:</label>
                        <div class="summary-content">${docSummaries[docData.name] || ''}</div>
                        <div class="summary-placeholder" style="${docSummaries[docData.name] ? 'display: none;' : ''}">Click to add summary...</div>
                    </div>
                    <div class="document-preview" ondblclick="openDocumentViewer(${docData.id})" title="Double-click to view full content">
                        ${preview}
                    </div>
                    <div class="document-tags" data-id="${docData.id}"></div>
                    <div class="confidence-score" data-id="${docData.id}"></div>
                </div>
            `;
            
            // Update if already analyzed
            if (docAiData[docData.name]) {
                updateDocumentCard(docData.id, docAiData[docData.name]);
            }
            
            return card;
        }

        function editDocumentSummary(documentId) {
            const summaryElement = document.querySelector(`[data-id="${documentId}"] .summary-content`);
            const placeholderElement = document.querySelector(`[data-id="${documentId}"] .summary-placeholder`);
            const currentSummary = summaryElement.textContent;
            
            summaryElement.contentEditable = true;
            summaryElement.focus();
            
            // Hide placeholder and show content field
            placeholderElement.style.display = 'none';
            summaryElement.style.display = 'block';
            
            // If empty, position cursor at beginning
            if (currentSummary.trim() === '') {
                const range = document.createRange();
                const sel = window.getSelection();
                range.setStart(summaryElement, 0);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
            } else {
                // Select all existing text for easy editing
                document.execCommand('selectAll', false, null);
            }
            
            summaryElement.onblur = () => {
                summaryElement.contentEditable = false;
                const newSummary = summaryElement.textContent.trim();
                const documentName = documents[documentId].name;
                
                if (newSummary === '') {
                    summaryElement.style.display = 'none';
                    placeholderElement.style.display = 'block';
                    delete docSummaries[documentName];
                } else {
                    docSummaries[documentName] = newSummary;
                }
            };
            
            summaryElement.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    summaryElement.blur();
                }
            };
        }

        async function analyzeDocuments() {
            if (!docModelLoaded || isDocAnalyzing || documents.length === 0) {
                if (!docModelLoaded) {
                    alert('Please wait for the AI model to load, or select a different model.');
                }
                return;
            }

            isDocAnalyzing = true;
            const analyzeBtn = document.getElementById('docAiAnalyzeBtn');
            const analyzeText = document.getElementById('docAiAnalyzeText');
            
            if (analyzeBtn && analyzeText) {
                analyzeBtn.disabled = true;
                analyzeText.textContent = 'Analyzing...';
            }

            try {
                for (let i = 0; i < documents.length; i++) {
                    const document = documents[i];
                    
                    try {
                        if (document.content) {
                            const analysis = docCurrentModel.analyze(document.content);
                            
                            docAiData[document.name] = {
                                keywords: analysis.keywords || [],
                                summary: analysis.summary || '',
                                embedding: analysis.embedding || [],
                                modelUsed: docModelConfigs[docModelType].name,
                                timestamp: new Date().toISOString()
                            };
                            
                            updateDocumentCard(document.id, docAiData[document.name]);
                            document.analyzed = true;
                        }
                    } catch (error) {
                        console.error(`Error analyzing ${document.name}:`, error);
                    }
                }
                
                if (analyzeText) {
                    analyzeText.textContent = 'AI Analyze';
                }
                
                const banner = document.getElementById('autoLoadBanner');
                banner.style.display = 'block';
                banner.innerHTML = `üß† Analyzed ${documents.length} documents with ${docModelConfigs[docModelType].name}`;
                setTimeout(() => banner.style.display = 'none', 3000);
                
            } catch (error) {
                console.error('Analysis error:', error);
                if (analyzeText) {
                    analyzeText.textContent = 'Analysis Failed';
                }
                alert('AI analysis failed. Please try again.');
            } finally {
                isDocAnalyzing = false;
                if (analyzeBtn) {
                    analyzeBtn.disabled = false;
                }
                updateDocumentStats();
            }
        }

        function updateDocumentCard(documentId, data) {
            const indicator = document.querySelector(`.ai-indicator[data-id="${documentId}"]`);
            const tagsContainer = document.querySelector(`.document-tags[data-id="${documentId}"]`);
            const confidenceElement = document.querySelector(`.confidence-score[data-id="${documentId}"]`);
            
            if (indicator) {
                indicator.classList.add('analyzed');
                indicator.innerHTML = `${docModelConfigs[docModelType].icon} Analyzed`;
            }
            
            if (tagsContainer && data.keywords) {
                tagsContainer.innerHTML = data.keywords.map(keyword => 
                    `<span class="tag ${keyword.score > 0.6 ? 'high-confidence' : 'medium-confidence'}">${keyword.word}</span>`
                ).join('');
            }
            
            if (confidenceElement) {
                const avgScore = data.keywords ? 
                    data.keywords.reduce((sum, k) => sum + k.score, 0) / data.keywords.length : 0;
                confidenceElement.innerHTML = `
                    <div class="confidence-text">
                        ${Math.round(avgScore * 100)}% relevance ‚Ä¢ ${data.keywords ? data.keywords.length : 0} keywords
                    </div>
                `;
            }
        }

        function updateDocumentStats() {
            const totalElement = document.getElementById('totalDocuments');
            const analyzedElement = document.getElementById('analyzedDocuments');
            
            if (totalElement) {
                totalElement.textContent = documents.length;
            }
            if (analyzedElement) {
                analyzedElement.textContent = Object.keys(docAiData).length;
            }
        }

        function updateDocumentGrid(value) {
            const grid = document.getElementById('documentGrid');
            
            if (grid) {
                // Remove existing grid classes
                grid.classList.remove('grid-1', 'grid-2', 'grid-3', 'grid-4', 'grid-5', 'grid-6');
                // Add new grid class
                grid.classList.add(`grid-${value}`);
            }
        }

        function clearDocumentGrid() {
            if (confirm('Are you sure you want to clear all documents? This will remove all loaded documents and analysis data.')) {
                documents = [];
                docAiData = {};
                docSummaries = {};
                renderDocuments();
                updateDocumentStats();
                
                const banner = document.getElementById('autoLoadBanner');
                banner.style.display = 'block';
                banner.innerHTML = 'üóëÔ∏è Document grid cleared';
                setTimeout(() => banner.style.display = 'none', 2000);
            }
        }

        function showDocumentSearch() {
            const searchHtml = `
                <div id="docSearchModal" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    z-index: 1000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                " onclick="closeDocumentSearch()">
                    <div style="
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        max-width: 600px;
                        width: 90%;
                        max-height: 80%;
                        overflow-y: auto;
                        cursor: default;
                    " onclick="event.stopPropagation()">
                        <h2 style="margin-bottom: 20px; color: #333;">üîç Search Documents</h2>
                        <input type="text" id="docSearchInput" placeholder="Search by filename, summary, or AI keywords..." style="
                            width: 100%;
                            padding: 12px;
                            border: 2px solid #ddd;
                            border-radius: 6px;
                            font-size: 16px;
                            margin-bottom: 20px;
                        " oninput="performDocumentSearch()">
                        <div id="docSearchResults" style="max-height: 300px; overflow-y: auto;"></div>
                        <div style="text-align: right; margin-top: 20px;">
                            <button onclick="closeDocumentSearch()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', searchHtml);
            setTimeout(() => document.getElementById('docSearchInput').focus(), 100);
        }

        function performDocumentSearch() {
            const query = document.getElementById('docSearchInput').value.toLowerCase();
            const resultsContainer = document.getElementById('docSearchResults');
            
            if (!query) {
                resultsContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">Type to search documents...</p>';
                return;
            }

            const results = documents.filter(doc => {
                const nameMatch = doc.name.toLowerCase().includes(query);
                const summaryMatch = docSummaries[doc.name] && docSummaries[doc.name].toLowerCase().includes(query);
                const keywordMatch = docAiData[doc.name] && 
                    docAiData[doc.name].keywords.some(k => k.word.toLowerCase().includes(query));
                const contentMatch = doc.content && doc.content.toLowerCase().includes(query);
                
                return nameMatch || summaryMatch || keywordMatch || contentMatch;
            });

            if (results.length === 0) {
                resultsContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No documents found matching your search.</p>';
                return;
            }

            resultsContainer.innerHTML = results.map(doc => {
                const summary = docSummaries[doc.name] || 'No summary available';
                const keywords = docAiData[doc.name] ? docAiData[doc.name].keywords.map(k => k.word).join(', ') : 'Not analyzed';
                
                return `
                    <div style="
                        border: 1px solid #ddd;
                        border-radius: 8px;
                        padding: 15px;
                        margin-bottom: 10px;
                        cursor: pointer;
                        transition: background-color 0.2s;
                    " onclick="openDocumentFromSearch(${doc.id})" onmouseover="this.style.backgroundColor='#f8f9fa'" onmouseout="this.style.backgroundColor='white'">
                        <h4 style="color: #2196F3; margin-bottom: 8px;">${doc.name}</h4>
                        <p style="color: #666; font-size: 14px; margin-bottom: 8px;"><strong>Summary:</strong> ${summary}</p>
                        <p style="color: #666; font-size: 14px;"><strong>Keywords:</strong> ${keywords}</p>
                    </div>
                `;
            }).join('');
        }

        function closeDocumentSearch() {
            const modal = document.getElementById('docSearchModal');
            if (modal) modal.remove();
        }

        function openDocumentFromSearch(documentId) {
            closeDocumentSearch();
            openDocumentViewer(documentId);
        }

        function openDocumentViewer(documentId) {
            console.log('Opening document viewer for ID:', documentId);
            console.log('Available documents:', documents.length);
            
            const docData = documents[documentId];
            if (!docData) {
                console.error('Document not found for ID:', documentId);
                alert('Document not found. Please try reloading the documents.');
                return;
            }
            
            if (!docData.content) {
                console.error('Document content not loaded for:', docData.name);
                alert('Document content is still loading. Please wait a moment and try again.');
                return;
            }
            
            console.log('Opening document:', docData.name);
            const analysis = docAiData[docData.name];
            const keywords = analysis ? analysis.keywords.map(k => k.word).join(', ') : 'Not analyzed';
            
            let contentSection = '';
            if (docData.type === 'pdf') {
                // Special handling for PDF files
                contentSection = `
                    <div style="text-align: center; padding: 40px; background: #f9f9f9; border-radius: 6px;">
                        <div style="font-size: 48px; margin-bottom: 16px;">üìÑ</div>
                        <h4>PDF Document</h4>
                        <p style="margin: 16px 0;">This is a PDF file: <strong>${docData.name}</strong></p>
                        <p style="color: #6c757d; margin-bottom: 20px;">PDF text extraction shows:</p>
                        <div style="background: white; padding: 20px; border-radius: 6px; text-align: left; font-family: monospace; white-space: pre-wrap; max-height: 300px; overflow-y: auto;">${docData.content}</div>
                        <button onclick="openPdfInBrowser(${documentId})" style="margin-top: 20px; padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;">üìÑ Open PDF in Browser</button>
                    </div>
                `;
            } else {
                // Regular text content
                contentSection = `
                    <div style="
                        max-height: 400px;
                        overflow-y: auto;
                        padding: 20px;
                        background: #f9f9f9;
                        border-radius: 6px;
                        font-family: 'Courier New', monospace;
                        font-size: 14px;
                        line-height: 1.6;
                        white-space: pre-wrap;
                    ">${docData.content}</div>
                `;
            }

            const viewerHtml = `
                <div id="docViewerModal" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.9);
                    z-index: 1000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                " onclick="closeDocumentViewer()">
                    <div style="
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        max-width: 80%;
                        max-height: 80%;
                        overflow-y: auto;
                        cursor: default;
                    " onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h2 style="color: #333;">${docData.name}</h2>
                            <button onclick="closeDocumentViewer()" style="
                                background: #dc3545;
                                color: white;
                                border: none;
                                padding: 8px 16px;
                                border-radius: 5px;
                                cursor: pointer;
                            ">Close</button>
                        </div>
                        <div style="margin-bottom: 20px; padding: 10px; background: #f8f9fa; border-radius: 6px;">
                            <p><strong>Type:</strong> ${docData.type.toUpperCase()}</p>
                            <p><strong>Size:</strong> ${formatFileSize(docData.file.size)}</p>
                            <p><strong>Keywords:</strong> ${keywords}</p>
                        </div>
                        ${contentSection}
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', viewerHtml);
        }

        function closeDocumentViewer() {
            const modal = document.getElementById('docViewerModal');
            if (modal) modal.remove();
        }

        function openPdfInBrowser(documentId) {
            const docData = documents[documentId];
            if (!docData || docData.type !== 'pdf') return;
            
            const url = URL.createObjectURL(docData.file);
            window.open(url, '_blank');
            // Clean up URL after a delay to allow browser to load it
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }

        function exportDocumentMetadata() {
            if (documents.length === 0) {
                alert('No documents to export metadata for');
                return;
            }

            const metadata = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                appName: 'AI Content Manager - Documents',
                modelUsed: docModelConfigs[docModelType].name,
                totalDocuments: documents.length,
                summaries: docSummaries,
                aiData: docAiData
            };

            const json = JSON.stringify(metadata, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai_documents_${docModelType}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            const banner = document.getElementById('autoLoadBanner');
            banner.style.display = 'block';
            banner.innerHTML = 'üíæ Document analysis data exported successfully!';
            setTimeout(() => banner.style.display = 'none', 3000);
        }

        function importDocumentMetadata() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const metadata = JSON.parse(e.target.result);
                            
                            if (metadata.summaries) {
                                Object.assign(docSummaries, metadata.summaries);
                            }
                            
                            if (metadata.aiData) {
                                Object.assign(docAiData, metadata.aiData);
                            }
                            
                            renderDocuments();
                            updateDocumentStats();
                            
                            const banner = document.getElementById('autoLoadBanner');
                            banner.style.display = 'block';
                            const aiCount = metadata.aiData ? Object.keys(metadata.aiData).length : 0;
                            const summaryCount = metadata.summaries ? Object.keys(metadata.summaries).length : 0;
                            banner.innerHTML = `üìÇ Imported ${aiCount} AI analysis records and ${summaryCount} summaries!`;
                            setTimeout(() => banner.style.display = 'none', 3000);
                        } catch (error) {
                            alert('Failed to import data. Please check the file format.');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function toggleDocumentAttributes() {
            const showDetails = document.getElementById('docShowAttributes').checked;
            const details = document.querySelectorAll('.document-attributes');
            
            details.forEach(detail => {
                if (showDetails) {
                    detail.style.display = 'block';
                } else {
                    detail.style.display = 'none';
                }
            });
        }

        function setupDocumentDragDrop() {
            const content = document.getElementById('documentsContent');
            if (!content) return;
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                content.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            content.addEventListener('drop', handleDocumentDrop, false);

            function handleDocumentDrop(e) {
                const dt = e.dataTransfer;
                const allFiles = Array.from(dt.files);
                
                // Filter for document files
                const documentFiles = allFiles.filter(file => {
                    const ext = file.name.split('.').pop().toLowerCase();
                    return ['txt', 'pdf', 'docx', 'rtf', 'md'].includes(ext);
                });
                
                // Check if any image files were dropped
                const imageFiles = allFiles.filter(file => {
                    const ext = file.name.split('.').pop().toLowerCase();
                    const isImage = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'].includes(ext) || 
                                   file.type.startsWith('image/');
                    return isImage;
                });
                
                if (imageFiles.length > 0) {
                    const banner = document.getElementById('autoLoadBanner');
                    banner.style.display = 'block';
                    banner.innerHTML = `üñºÔ∏è Found ${imageFiles.length} image file(s). Please drag them to the <strong>Images</strong> tab instead!`;
                    banner.style.background = '#ffc107';
                    banner.style.color = '#856404';
                    setTimeout(() => {
                        banner.style.display = 'none';
                        banner.style.background = '';
                        banner.style.color = '';
                    }, 5000);
                }

                if (documentFiles.length > 0) {
                    loadDocuments(documentFiles);
                } else if (allFiles.length > 0 && imageFiles.length === 0) {
                    alert(`${allFiles.length} file(s) are not supported document formats. Please use TXT, PDF, DOCX, RTF, or MD files.`);
                }
            }
        }

        // Date formatter
        function formatDate(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
        }

        // Initialize document model on load
        setTimeout(() => {
            handleDocumentModelChange();
            setupDocumentDragDrop();
        }, 1000);

        // ===== AUDIO FUNCTIONALITY =====
        
        // Audio processing variables
        let audioFiles = [];
        let audioAiData = {};
        let audioSummaries = {};
        let audioCurrentModel = null;
        let isAudioAnalyzing = false;
        let audioModelLoaded = false;

        // Video processing variables
        let videoFiles = [];
        let videoAiData = {};
        let videoSummaries = {};
        let videoCurrentModel = null;
        let isVideoAnalyzing = false;
        let videoModelLoaded = false;
        let audioModelType = 'audiobert';

        // Audio AI Model configurations
        const audioModelConfigs = {
            audiobert: {
                name: 'Audio-BERT',
                icon: 'üéµ',
                color: '#667eea',
                description: 'Fast audio embedding and similarity search',
                loadModel: async () => {
                    return {
                        analyze: (audioFile) => {
                            const genres = ['Classical', 'Jazz', 'Rock', 'Electronic', 'Folk', 'Hip-Hop', 'Pop', 'Blues', 'Country', 'Reggae'];
                            const moods = ['Energetic', 'Calm', 'Uplifting', 'Melancholic', 'Dramatic', 'Peaceful', 'Intense', 'Cheerful'];
                            const instruments = ['Piano', 'Guitar', 'Violin', 'Drums', 'Synthesizer', 'Vocals', 'Bass', 'Saxophone', 'Trumpet'];
                            
                            const tags = [];
                            
                            // Add genre tags
                            for (let i = 0; i < Math.floor(Math.random() * 2) + 1; i++) {
                                const genre = genres[Math.floor(Math.random() * genres.length)];
                                if (!tags.includes(genre)) tags.push(genre);
                            }
                            
                            // Add mood tags
                            for (let i = 0; i < Math.floor(Math.random() * 2) + 1; i++) {
                                const mood = moods[Math.floor(Math.random() * moods.length)];
                                if (!tags.includes(mood)) tags.push(mood);
                            }
                            
                            // Add instrument tags
                            for (let i = 0; i < Math.floor(Math.random() * 3) + 1; i++) {
                                const instrument = instruments[Math.floor(Math.random() * instruments.length)];
                                if (!tags.includes(instrument)) tags.push(instrument);
                            }
                            
                            return {
                                tags: tags.map(tag => ({
                                    word: tag,
                                    score: Math.random() * 0.4 + 0.6
                                })),
                                embedding: Array.from({length: 128}, () => Math.random()),
                                genre: tags.filter(t => genres.includes(t))[0] || 'Unknown',
                                mood: tags.filter(t => moods.includes(t))[0] || 'Unknown',
                                tempo: Math.floor(Math.random() * 120) + 60 // BPM
                            };
                        }
                    };
                }
            },
            musiccnn: {
                name: 'MusicCNN',
                icon: 'üéº',
                color: '#764ba2',
                description: 'Music analysis and genre classification',
                loadModel: async () => {
                    return {
                        analyze: (audioFile) => {
                            const genres = ['Classical', 'Jazz', 'Rock', 'Electronic', 'Folk', 'Hip-Hop', 'Pop', 'Blues', 'Country', 'Reggae'];
                            const moods = ['Energetic', 'Calm', 'Uplifting', 'Melancholic', 'Dramatic', 'Peaceful', 'Intense', 'Cheerful'];
                            const instruments = ['Piano', 'Guitar', 'Violin', 'Drums', 'Synthesizer', 'Vocals', 'Bass', 'Saxophone', 'Trumpet'];
                            
                            const tags = [];
                            
                            // MusicCNN focuses more on musical elements
                            for (let i = 0; i < Math.floor(Math.random() * 3) + 2; i++) {
                                const genre = genres[Math.floor(Math.random() * genres.length)];
                                if (!tags.includes(genre)) tags.push(genre);
                            }
                            
                            for (let i = 0; i < Math.floor(Math.random() * 4) + 2; i++) {
                                const instrument = instruments[Math.floor(Math.random() * instruments.length)];
                                if (!tags.includes(instrument)) tags.push(instrument);
                            }
                            
                            return {
                                tags: tags.map(tag => ({
                                    word: tag,
                                    score: Math.random() * 0.3 + 0.7
                                })),
                                embedding: Array.from({length: 256}, () => Math.random()),
                                genre: tags.filter(t => genres.includes(t))[0] || 'Unknown',
                                mood: moods[Math.floor(Math.random() * moods.length)],
                                tempo: Math.floor(Math.random() * 140) + 50
                            };
                        }
                    };
                }
            },
            universal: {
                name: 'Universal Audio',
                icon: 'üöÄ',
                color: '#4CAF50',
                description: 'Advanced audio understanding and analysis',
                loadModel: async () => {
                    return {
                        analyze: (audioFile) => {
                            const genres = ['Classical', 'Jazz', 'Rock', 'Electronic', 'Folk', 'Hip-Hop', 'Pop', 'Blues', 'Country', 'Reggae'];
                            const moods = ['Energetic', 'Calm', 'Uplifting', 'Melancholic', 'Dramatic', 'Peaceful', 'Intense', 'Cheerful'];
                            const instruments = ['Piano', 'Guitar', 'Violin', 'Drums', 'Synthesizer', 'Vocals', 'Bass', 'Saxophone', 'Trumpet'];
                            const features = ['Vocals', 'Instrumental', 'Acoustic', 'Electronic', 'Live Recording', 'Studio', 'Ambient'];
                            
                            const tags = [];
                            
                            // Universal model gives comprehensive analysis
                            for (let i = 0; i < Math.floor(Math.random() * 2) + 2; i++) {
                                const genre = genres[Math.floor(Math.random() * genres.length)];
                                if (!tags.includes(genre)) tags.push(genre);
                            }
                            
                            for (let i = 0; i < Math.floor(Math.random() * 3) + 2; i++) {
                                const instrument = instruments[Math.floor(Math.random() * instruments.length)];
                                if (!tags.includes(instrument)) tags.push(instrument);
                            }
                            
                            for (let i = 0; i < Math.floor(Math.random() * 2) + 1; i++) {
                                const feature = features[Math.floor(Math.random() * features.length)];
                                if (!tags.includes(feature)) tags.push(feature);
                            }
                            
                            return {
                                tags: tags.map(tag => ({
                                    word: tag,
                                    score: Math.random() * 0.2 + 0.8
                                })),
                                embedding: Array.from({length: 512}, () => Math.random()),
                                genre: tags.filter(t => genres.includes(t))[0] || 'Unknown',
                                mood: moods[Math.floor(Math.random() * moods.length)],
                                tempo: Math.floor(Math.random() * 160) + 40
                            };
                        }
                    };
                }
            }
        };

        // Video model type
        let videoModelType = 'videobert';

        // Video AI Model configurations
        const videoModelConfigs = {
            videobert: {
                name: 'Video-BERT',
                icon: 'üé¨',
                color: '#667eea',
                description: 'Fast video embedding and similarity search',
                loadModel: async () => {
                    return {
                        analyze: (videoFile) => {
                            const videoScenes = ['indoor', 'outdoor', 'kitchen', 'office', 'nature', 'city', 'home', 'restaurant', 'beach', 'park'];
                            const videoActions = ['talking', 'walking', 'cooking', 'working', 'playing', 'dancing', 'driving', 'sitting', 'running', 'eating'];
                            const videoObjects = ['person', 'car', 'food', 'animal', 'building', 'furniture', 'technology', 'clothing', 'plant', 'water'];
                            
                            const tags = [];
                            
                            // Add scene tags
                            for (let i = 0; i < Math.floor(Math.random() * 2) + 1; i++) {
                                const scene = videoScenes[Math.floor(Math.random() * videoScenes.length)];
                                if (!tags.includes(scene)) tags.push(scene);
                            }
                            
                            // Add action tags
                            for (let i = 0; i < Math.floor(Math.random() * 2) + 1; i++) {
                                const action = videoActions[Math.floor(Math.random() * videoActions.length)];
                                if (!tags.includes(action)) tags.push(action);
                            }
                            
                            // Add object tags
                            for (let i = 0; i < Math.floor(Math.random() * 3) + 1; i++) {
                                const object = videoObjects[Math.floor(Math.random() * videoObjects.length)];
                                if (!tags.includes(object)) tags.push(object);
                            }
                            
                            return {
                                tags: tags.map(tag => ({
                                    word: tag,
                                    score: Math.random() * 0.4 + 0.6
                                })),
                                embedding: Array.from({length: 128}, () => Math.random()),
                                scene: tags.filter(t => videoScenes.includes(t))[0] || 'Unknown',
                                activity: tags.filter(t => videoActions.includes(t))[0] || 'Unknown'
                            };
                        }
                    };
                }
            },
            videomae: {
                name: 'VideoMAE',
                icon: 'üé•',
                color: '#764ba2',
                description: 'Scene detection and action recognition',
                loadModel: async () => {
                    return {
                        analyze: (videoFile) => {
                            const videoScenes = ['indoor scene', 'outdoor scene', 'kitchen activity', 'office environment', 'nature documentary', 'city street', 'home interior', 'restaurant dining'];
                            const videoActions = ['conversation', 'movement', 'cooking activity', 'work meeting', 'sports activity', 'performance', 'transportation', 'leisure activity'];
                            const videoObjects = ['multiple people', 'vehicle', 'food items', 'animals', 'architecture', 'furniture', 'electronics', 'textiles'];
                            
                            const tags = [];
                            
                            // Add more detailed scene analysis
                            for (let i = 0; i < Math.floor(Math.random() * 3) + 1; i++) {
                                const scene = videoScenes[Math.floor(Math.random() * videoScenes.length)];
                                if (!tags.includes(scene)) tags.push(scene);
                            }
                            
                            // Add action recognition
                            for (let i = 0; i < Math.floor(Math.random() * 2) + 1; i++) {
                                const action = videoActions[Math.floor(Math.random() * videoActions.length)];
                                if (!tags.includes(action)) tags.push(action);
                            }
                            
                            // Add object detection
                            for (let i = 0; i < Math.floor(Math.random() * 4) + 2; i++) {
                                const object = videoObjects[Math.floor(Math.random() * videoObjects.length)];
                                if (!tags.includes(object)) tags.push(object);
                            }
                            
                            return {
                                tags: tags.map(tag => ({
                                    word: tag,
                                    score: Math.random() * 0.3 + 0.7
                                })),
                                embedding: Array.from({length: 256}, () => Math.random()),
                                scene: videoScenes[Math.floor(Math.random() * videoScenes.length)],
                                activity: videoActions[Math.floor(Math.random() * videoActions.length)]
                            };
                        }
                    };
                }
            },
            universal: {
                name: 'Universal Video',
                icon: 'üöÄ',
                color: '#28a745',
                description: 'Advanced video understanding and analysis',
                loadModel: async () => {
                    return {
                        analyze: (videoFile) => {
                            const videoScenes = ['indoor environment', 'outdoor landscape', 'commercial kitchen', 'modern office', 'natural habitat', 'urban setting', 'residential home', 'dining establishment', 'recreational area', 'educational space'];
                            const videoActions = ['verbal communication', 'physical movement', 'culinary preparation', 'professional meeting', 'recreational sport', 'artistic performance', 'vehicle operation', 'social gathering', 'educational activity', 'creative work'];
                            const videoObjects = ['human subjects', 'transportation vehicle', 'culinary items', 'wildlife', 'architectural structure', 'interior furnishings', 'electronic devices', 'textile materials', 'natural elements', 'tools and equipment'];
                            
                            const tags = [];
                            
                            // Advanced scene understanding
                            for (let i = 0; i < Math.floor(Math.random() * 4) + 2; i++) {
                                const scene = videoScenes[Math.floor(Math.random() * videoScenes.length)];
                                if (!tags.includes(scene)) tags.push(scene);
                            }
                            
                            // Complex activity recognition
                            for (let i = 0; i < Math.floor(Math.random() * 3) + 1; i++) {
                                const action = videoActions[Math.floor(Math.random() * videoActions.length)];
                                if (!tags.includes(action)) tags.push(action);
                            }
                            
                            // Comprehensive object detection
                            for (let i = 0; i < Math.floor(Math.random() * 5) + 3; i++) {
                                const object = videoObjects[Math.floor(Math.random() * videoObjects.length)];
                                if (!tags.includes(object)) tags.push(object);
                            }
                            
                            return {
                                tags: tags.map(tag => ({
                                    word: tag,
                                    score: Math.random() * 0.2 + 0.8
                                })),
                                embedding: Array.from({length: 512}, () => Math.random()),
                                scene: videoScenes[Math.floor(Math.random() * videoScenes.length)],
                                activity: videoActions[Math.floor(Math.random() * videoActions.length)]
                            };
                        }
                    };
                }
            }
        };

        // Audio model change handler
        async function handleAudioModelChange() {
            const select = document.getElementById('audioAiModel');
            const newModelType = select.value;
            
            if (newModelType === audioModelType && audioModelLoaded) return;
            
            audioModelType = newModelType;
            audioModelLoaded = false;
            
            // Disable the analyze button while loading
            const analyzeBtn = document.getElementById('audioAiAnalyzeBtn');
            const analyzeText = document.getElementById('audioAiAnalyzeText');
            const analyzeIcon = document.getElementById('audioAiAnalyzeIcon');
            
            if (analyzeBtn) analyzeBtn.disabled = true;
            if (analyzeText) analyzeText.textContent = 'Loading Model...';
            if (analyzeIcon) analyzeIcon.textContent = '‚è≥';
            
            try {
                audioCurrentModel = await audioModelConfigs[audioModelType].loadModel();
                audioModelLoaded = true;
                
                // Enable the analyze button once model is loaded
                if (analyzeBtn) analyzeBtn.disabled = false;
                if (analyzeText) analyzeText.textContent = 'AI Analyze';
                if (analyzeIcon) analyzeIcon.textContent = audioModelConfigs[audioModelType].icon;
                
                const banner = document.getElementById('autoLoadBanner');
                banner.style.display = 'block';
                banner.innerHTML = `üß† ${audioModelConfigs[audioModelType].name} model loaded successfully!`;
                setTimeout(() => banner.style.display = 'none', 2000);
            } catch (error) {
                console.error('Error loading audio model:', error);
                
                // Keep button disabled on error
                if (analyzeBtn) analyzeBtn.disabled = true;
                if (analyzeText) analyzeText.textContent = 'Model Failed';
                if (analyzeIcon) analyzeIcon.textContent = '‚ùå';
                
                alert('Failed to load AI model. Please try again.');
            }
        }

        // Audio file handlers
        function selectAudios() {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.accept = '.mp3,.wav,.flac,.aac,.ogg,.m4a,audio/*';
            input.onchange = handleAudioFiles;
            input.click();
        }

        function selectAudioFolder() {
            const input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.onchange = handleAudioFiles;
            input.click();
        }

        function handleAudioFiles(event) {
            const files = Array.from(event.target.files).filter(file => {
                const ext = file.name.split('.').pop().toLowerCase();
                return ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'].includes(ext) || 
                       file.type.startsWith('audio/');
            });

            if (files.length === 0) {
                alert('No supported audio files found. Please select MP3, WAV, FLAC, AAC, OGG, or M4A files.');
                return;
            }

            loadAudioFiles(files);
        }

        function loadAudioFiles(files) {
            // Filter out duplicate files based on name and size
            const newFiles = files.filter(file => {
                return !audioFiles.some(existing => 
                    existing.name === file.name && existing.file.size === file.size
                );
            });
            
            if (newFiles.length === 0) {
                alert('All selected audio files are already loaded.');
                return;
            }
            
            // Append new audio files to existing array
            const startingId = audioFiles.length;
            const newAudioFiles = newFiles.map((file, index) => ({
                id: startingId + index,
                name: file.name,
                file: file,
                type: getAudioType(file.name),
                url: URL.createObjectURL(file),
                analyzed: false
            }));
            
            audioFiles.push(...newAudioFiles);
            
            renderAudioFiles();
            updateAudioStats();
            
            const banner = document.getElementById('autoLoadBanner');
            banner.style.display = 'block';
            banner.innerHTML = `üéµ Loaded ${newFiles.length} audio files`;
            setTimeout(() => banner.style.display = 'none', 2000);
            
            if (newFiles.length < files.length) {
                const duplicates = files.length - newFiles.length;
                alert(`Added ${newFiles.length} new audio files. ${duplicates} duplicate(s) were skipped.`);
            }
        }

        function getAudioType(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            switch(ext) {
                case 'mp3': return 'mp3';
                case 'wav': return 'wav';
                case 'flac': return 'flac';
                case 'aac': return 'aac';
                case 'ogg': return 'ogg';
                case 'm4a': return 'm4a';
                default: return 'audio';
            }
        }

        function renderAudioFiles() {
            const grid = document.getElementById('audioGrid');
            if (!grid) return;
            
            grid.innerHTML = '';
            
            audioFiles.forEach(audioFile => {
                const card = createAudioCard(audioFile);
                grid.appendChild(card);
            });
        }

        function createAudioCard(audioData) {
            const card = document.createElement('div');
            card.className = 'audio-card';
            
            const aiIndicatorClass = audioAiData[audioData.name] ? 'analyzed' : '';
            const showDetails = document.getElementById('audioShowAttributes') ? 
                document.getElementById('audioShowAttributes').checked : false;
            
            card.innerHTML = `
                <div class="audio-header">
                    <div class="audio-type ${audioData.type}">${audioData.type.toUpperCase()}</div>
                    <div class="ai-indicator ${aiIndicatorClass}" data-id="${audioData.id}">
                        ${audioModelConfigs[audioModelType].icon} ${audioAiData[audioData.name] ? 'Analyzed' : 'Not Analyzed'}
                    </div>
                </div>
                <div class="audio-content">
                    <div class="audio-title">${audioData.name}</div>
                    <div class="audio-attributes" data-id="${audioData.id}" style="${showDetails ? '' : 'display: none;'}">
                        <div class="attribute-row">
                            <span class="attribute-label">Size:</span>
                            <span class="attribute-value">${formatFileSize(audioData.file.size)}</span>
                        </div>
                        <div class="attribute-row">
                            <span class="attribute-label">Modified:</span>
                            <span class="attribute-value">${formatDate(audioData.file.lastModified)}</span>
                        </div>
                    </div>
                    <div class="audio-player">
                        <audio controls preload="none">
                            <source src="${audioData.url}" type="${audioData.file.type}">
                            Your browser does not support the audio element.
                        </audio>
                    </div>
                    <div class="audio-summary" data-id="${audioData.id}" onclick="editAudioSummary(${audioData.id})">
                        <label class="summary-label">Summary:</label>
                        <div class="summary-content">${audioSummaries[audioData.name] || ''}</div>
                        <div class="summary-placeholder" style="${audioSummaries[audioData.name] ? 'display: none;' : ''}">Click to add summary...</div>
                    </div>
                    <div class="audio-tags" data-id="${audioData.id}"></div>
                    <div class="confidence-score" data-id="${audioData.id}"></div>
                </div>
            `;
            
            // Update if already analyzed
            if (audioAiData[audioData.name]) {
                updateAudioCard(audioData.id, audioAiData[audioData.name]);
            }
            
            return card;
        }

        function editAudioSummary(audioId) {
            const summaryElement = document.querySelector(`[data-id="${audioId}"] .summary-content`);
            const placeholderElement = document.querySelector(`[data-id="${audioId}"] .summary-placeholder`);
            const currentSummary = summaryElement.textContent;
            
            summaryElement.contentEditable = true;
            summaryElement.focus();
            
            // Hide placeholder and show content field
            placeholderElement.style.display = 'none';
            summaryElement.style.display = 'block';
            
            // If empty, position cursor at beginning
            if (currentSummary.trim() === '') {
                const range = document.createRange();
                const sel = window.getSelection();
                range.setStart(summaryElement, 0);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
            } else {
                // Select all existing text for easy editing
                document.execCommand('selectAll', false, null);
            }
            
            summaryElement.onblur = () => {
                summaryElement.contentEditable = false;
                const newSummary = summaryElement.textContent.trim();
                const audioName = audioFiles[audioId].name;
                
                if (newSummary === '') {
                    summaryElement.style.display = 'none';
                    placeholderElement.style.display = 'block';
                    delete audioSummaries[audioName];
                } else {
                    audioSummaries[audioName] = newSummary;
                }
            };
            
            summaryElement.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    summaryElement.blur();
                }
            };
        }

        async function analyzeAudios() {
            if (!audioModelLoaded || isAudioAnalyzing || audioFiles.length === 0) {
                if (!audioModelLoaded) {
                    alert('Please wait for the AI model to load, or select a different model.');
                }
                return;
            }

            isAudioAnalyzing = true;
            const analyzeBtn = document.getElementById('audioAiAnalyzeBtn');
            const analyzeText = document.getElementById('audioAiAnalyzeText');
            
            if (analyzeBtn && analyzeText) {
                analyzeBtn.disabled = true;
                analyzeText.textContent = 'Analyzing...';
            }

            try {
                for (let i = 0; i < audioFiles.length; i++) {
                    const audioFile = audioFiles[i];
                    
                    try {
                        const analysis = audioCurrentModel.analyze(audioFile.file);
                        
                        audioAiData[audioFile.name] = {
                            tags: analysis.tags || [],
                            genre: analysis.genre || 'Unknown',
                            mood: analysis.mood || 'Unknown',
                            tempo: analysis.tempo || 0,
                            embedding: analysis.embedding || [],
                            modelUsed: audioModelConfigs[audioModelType].name,
                            timestamp: new Date().toISOString()
                        };
                        
                        updateAudioCard(audioFile.id, audioAiData[audioFile.name]);
                        audioFile.analyzed = true;
                    } catch (error) {
                        console.error(`Error analyzing ${audioFile.name}:`, error);
                    }
                }
                
                if (analyzeText) {
                    analyzeText.textContent = 'AI Analyze';
                }
                
                const banner = document.getElementById('autoLoadBanner');
                banner.style.display = 'block';
                banner.innerHTML = `üß† Analyzed ${audioFiles.length} audio files with ${audioModelConfigs[audioModelType].name}`;
                setTimeout(() => banner.style.display = 'none', 3000);
                
            } catch (error) {
                console.error('Analysis error:', error);
                if (analyzeText) {
                    analyzeText.textContent = 'Analysis Failed';
                }
                alert('AI analysis failed. Please try again.');
            } finally {
                isAudioAnalyzing = false;
                if (analyzeBtn) {
                    analyzeBtn.disabled = false;
                }
                updateAudioStats();
            }
        }

        function updateAudioCard(audioId, data) {
            const indicator = document.querySelector(`.ai-indicator[data-id="${audioId}"]`);
            const tagsContainer = document.querySelector(`.audio-tags[data-id="${audioId}"]`);
            const confidenceElement = document.querySelector(`.confidence-score[data-id="${audioId}"]`);
            
            if (indicator) {
                indicator.classList.add('analyzed');
                indicator.innerHTML = `${audioModelConfigs[audioModelType].icon} Analyzed`;
            }
            
            if (tagsContainer && data.tags) {
                tagsContainer.innerHTML = data.tags.map(tag => 
                    `<span class="tag ${tag.score > 0.7 ? 'high-confidence' : 'medium-confidence'}">${tag.word}</span>`
                ).join('');
            }
            
            if (confidenceElement) {
                const avgScore = data.tags ? 
                    data.tags.reduce((sum, k) => sum + k.score, 0) / data.tags.length : 0;
                confidenceElement.innerHTML = `
                    <div class="confidence-text">
                        ${Math.round(avgScore * 100)}% confidence ‚Ä¢ Genre: ${data.genre} ‚Ä¢ BPM: ${data.tempo}
                    </div>
                `;
            }
        }

        function updateAudioStats() {
            const totalElement = document.getElementById('totalAudios');
            const analyzedElement = document.getElementById('analyzedAudios');
            
            if (totalElement) {
                totalElement.textContent = audioFiles.length;
            }
            if (analyzedElement) {
                analyzedElement.textContent = Object.keys(audioAiData).length;
            }
        }

        function updateAudioGrid(value) {
            const grid = document.getElementById('audioGrid');
            
            if (grid) {
                // Remove existing grid classes
                grid.classList.remove('grid-1', 'grid-2', 'grid-3', 'grid-4', 'grid-5', 'grid-6');
                // Add new grid class
                grid.classList.add(`grid-${value}`);
            }
        }

        function clearAudioGrid() {
            if (confirm('Are you sure you want to clear all audio files? This will remove all loaded audio files and analysis data.')) {
                // Revoke object URLs to prevent memory leaks
                audioFiles.forEach(audioFile => {
                    if (audioFile.url) {
                        URL.revokeObjectURL(audioFile.url);
                    }
                });
                
                audioFiles = [];
                audioAiData = {};
                audioSummaries = {};
                renderAudioFiles();
                updateAudioStats();
                
                const banner = document.getElementById('autoLoadBanner');
                banner.style.display = 'block';
                banner.innerHTML = 'üóëÔ∏è Audio grid cleared';
                setTimeout(() => banner.style.display = 'none', 2000);
            }
        }

        function showAudioSearch() {
            const searchHtml = `
                <div id="audioSearchModal" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    z-index: 1000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                " onclick="closeAudioSearch()">
                    <div style="
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        max-width: 600px;
                        width: 90%;
                        max-height: 80%;
                        overflow-y: auto;
                        cursor: default;
                    " onclick="event.stopPropagation()">
                        <h2 style="margin-bottom: 20px; color: #333;">üîç Search Audio Files</h2>
                        <input type="text" id="audioSearchInput" placeholder="Search by filename, summary, genre, mood, or AI tags..." style="
                            width: 100%;
                            padding: 12px;
                            border: 2px solid #ddd;
                            border-radius: 6px;
                            font-size: 16px;
                            margin-bottom: 20px;
                        " oninput="performAudioSearch()">
                        <div id="audioSearchResults" style="max-height: 300px; overflow-y: auto;"></div>
                        <div style="text-align: right; margin-top: 20px;">
                            <button onclick="closeAudioSearch()" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">Close</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', searchHtml);
            setTimeout(() => document.getElementById('audioSearchInput').focus(), 100);
        }

        function performAudioSearch() {
            const query = document.getElementById('audioSearchInput').value.toLowerCase();
            const resultsContainer = document.getElementById('audioSearchResults');
            
            if (!query) {
                resultsContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">Type to search audio files...</p>';
                return;
            }

            const results = audioFiles.filter(audioFile => {
                const nameMatch = audioFile.name.toLowerCase().includes(query);
                const summaryMatch = audioSummaries[audioFile.name] && audioSummaries[audioFile.name].toLowerCase().includes(query);
                const aiData = audioAiData[audioFile.name];
                const tagMatch = aiData && aiData.tags.some(k => k.word.toLowerCase().includes(query));
                const genreMatch = aiData && aiData.genre && aiData.genre.toLowerCase().includes(query);
                const moodMatch = aiData && aiData.mood && aiData.mood.toLowerCase().includes(query);
                
                return nameMatch || summaryMatch || tagMatch || genreMatch || moodMatch;
            });

            if (results.length === 0) {
                resultsContainer.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No audio files found matching your search.</p>';
                return;
            }

            resultsContainer.innerHTML = results.map(audioFile => {
                const summary = audioSummaries[audioFile.name] || 'No summary available';
                const aiData = audioAiData[audioFile.name];
                const tags = aiData ? aiData.tags.map(k => k.word).join(', ') : 'Not analyzed';
                const genre = aiData ? aiData.genre : 'Unknown';
                const mood = aiData ? aiData.mood : 'Unknown';
                
                return `
                    <div style="
                        border: 1px solid #ddd;
                        border-radius: 8px;
                        padding: 15px;
                        margin-bottom: 10px;
                        cursor: pointer;
                        transition: background-color 0.2s;
                    " onclick="openAudioFromSearch(${audioFile.id})" onmouseover="this.style.backgroundColor='#f8f9fa'" onmouseout="this.style.backgroundColor='white'">
                        <h4 style="color: #667eea; margin-bottom: 8px;">üéµ ${audioFile.name}</h4>
                        <p style="color: #666; font-size: 14px; margin-bottom: 4px;"><strong>Summary:</strong> ${summary}</p>
                        <p style="color: #666; font-size: 14px; margin-bottom: 4px;"><strong>Genre:</strong> ${genre} | <strong>Mood:</strong> ${mood}</p>
                        <p style="color: #666; font-size: 14px;"><strong>Tags:</strong> ${tags}</p>
                    </div>
                `;
            }).join('');
        }

        function closeAudioSearch() {
            const modal = document.getElementById('audioSearchModal');
            if (modal) modal.remove();
        }

        function openAudioFromSearch(audioId) {
            closeAudioSearch();
            // Find the audio file and open it in a modal player instead of new tab
            const audioFile = audioFiles.find(audio => audio.id === audioId);
            if (audioFile && audioFile.file) {
                showAudioPlayer(audioFile);
            } else {
                // Fallback: scroll to the audio card and highlight it briefly
                const audioCard = document.querySelector(`.audio-card [data-id="${audioId}"]`);
                if (audioCard) {
                    const card = audioCard.closest('.audio-card');
                    card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    card.style.boxShadow = '0 0 20px rgba(102, 126, 234, 0.5)';
                    setTimeout(() => {
                        card.style.boxShadow = '';
                    }, 2000);
                }
            }
        }

        function showAudioPlayer(audioFile) {
            const analysis = audioAiData[audioFile.name];
            const tags = analysis ? analysis.tags.map(t => t.word).join(', ') : 'Not analyzed';
            const genre = analysis ? analysis.genre : 'Unknown';
            const mood = analysis ? analysis.mood : 'Unknown';
            const tempo = analysis ? analysis.tempo : 'Unknown';
            
            const playerHtml = `
                <div id="audioPlayerModal" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.9);
                    z-index: 1000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                " onclick="closeAudioPlayer()">
                    <div style="
                        background: white;
                        border-radius: 12px;
                        padding: 30px;
                        max-width: 500px;
                        width: 90%;
                        cursor: default;
                        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                    " onclick="event.stopPropagation()">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px; gap: 15px;">
                            <h2 style="
                                color: #333; 
                                margin: 0; 
                                font-size: 16px; 
                                line-height: 1.3;
                                word-break: break-word;
                                flex: 1;
                                overflow-wrap: break-word;
                            ">üéµ ${audioFile.name}</h2>
                            <button onclick="closeAudioPlayer()" style="
                                background: #dc3545;
                                color: white;
                                border: none;
                                padding: 8px 12px;
                                border-radius: 5px;
                                cursor: pointer;
                                font-weight: bold;
                                flex-shrink: 0;
                                min-width: 32px;
                            ">‚úï</button>
                        </div>
                        
                        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">
                                <div><strong>Type:</strong> ${audioFile.type.toUpperCase()}</div>
                                <div><strong>Size:</strong> ${formatFileSize(audioFile.file.size)}</div>
                                <div><strong>Genre:</strong> ${genre}</div>
                                <div><strong>Mood:</strong> ${mood}</div>
                                <div style="grid-column: 1 / -1;"><strong>Tags:</strong> ${tags}</div>
                            </div>
                        </div>
                        
                        <div style="
                            background: #f8f9fa;
                            padding: 20px;
                            border-radius: 8px;
                            text-align: center;
                        ">
                            <audio controls autoplay style="width: 100%; margin-bottom: 10px;">
                                <source src="${audioFile.url}" type="${audioFile.file.type}">
                                Your browser does not support the audio element.
                            </audio>
                            <p style="color: #666; font-size: 12px; margin: 0;">
                                ${tempo !== 'Unknown' ? `BPM: ${tempo} ‚Ä¢ ` : ''}Click play button to start
                            </p>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', playerHtml);
        }

        function closeAudioPlayer() {
            const modal = document.getElementById('audioPlayerModal');
            if (modal) {
                // Stop any playing audio
                const audio = modal.querySelector('audio');
                if (audio) {
                    audio.pause();
                    audio.currentTime = 0;
                }
                modal.remove();
            }
        }

        function exportAudioMetadata() {
            if (audioFiles.length === 0) {
                alert('No audio files to export metadata for');
                return;
            }

            const metadata = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                appName: 'AI Content Manager - Audio',
                modelUsed: audioModelConfigs[audioModelType].name,
                totalAudioFiles: audioFiles.length,
                summaries: audioSummaries,
                aiData: audioAiData
            };

            const json = JSON.stringify(metadata, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai_audio_${audioModelType}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            const banner = document.getElementById('autoLoadBanner');
            banner.style.display = 'block';
            banner.innerHTML = 'üíæ Audio analysis data exported successfully!';
            setTimeout(() => banner.style.display = 'none', 3000);
        }

        function importAudioMetadata() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const metadata = JSON.parse(e.target.result);
                            
                            if (metadata.summaries) {
                                Object.assign(audioSummaries, metadata.summaries);
                            }
                            
                            if (metadata.aiData) {
                                Object.assign(audioAiData, metadata.aiData);
                            }
                            
                            renderAudioFiles();
                            updateAudioStats();
                            
                            const banner = document.getElementById('autoLoadBanner');
                            banner.style.display = 'block';
                            const aiCount = metadata.aiData ? Object.keys(metadata.aiData).length : 0;
                            const summaryCount = metadata.summaries ? Object.keys(metadata.summaries).length : 0;
                            banner.innerHTML = `üìÇ Imported ${aiCount} AI analysis records and ${summaryCount} summaries!`;
                            setTimeout(() => banner.style.display = 'none', 3000);
                        } catch (error) {
                            alert('Failed to import data. Please check the file format.');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function toggleAudioAttributes() {
            const showDetails = document.getElementById('audioShowAttributes').checked;
            const details = document.querySelectorAll('.audio-attributes');
            
            details.forEach(detail => {
                if (showDetails) {
                    detail.style.display = 'block';
                } else {
                    detail.style.display = 'none';
                }
            });
        }

        function setupAudioDragDrop() {
            const content = document.getElementById('audiosContent');
            if (!content) return;
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                content.addEventListener(eventName, preventDefaults, false);
            });

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            content.addEventListener('drop', handleAudioDrop, false);

            function handleAudioDrop(e) {
                const dt = e.dataTransfer;
                const allFiles = Array.from(dt.files);
                
                // Filter for audio files
                const audioFilesFromDrop = allFiles.filter(file => {
                    const ext = file.name.split('.').pop().toLowerCase();
                    return ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'].includes(ext) || 
                           file.type.startsWith('audio/');
                });
                
                // Check if any non-audio files were dropped
                const nonAudioFiles = allFiles.filter(file => {
                    const ext = file.name.split('.').pop().toLowerCase();
                    const isAudio = ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'].includes(ext) || 
                                   file.type.startsWith('audio/');
                    return !isAudio;
                });
                
                if (nonAudioFiles.length > 0) {
                    const imageFiles = nonAudioFiles.filter(file => {
                        const ext = file.name.split('.').pop().toLowerCase();
                        const isImage = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'svg'].includes(ext) || 
                                       file.type.startsWith('image/');
                        return isImage;
                    });
                    
                    const documentFiles = nonAudioFiles.filter(file => {
                        const ext = file.name.split('.').pop().toLowerCase();
                        return ['txt', 'pdf', 'docx', 'rtf', 'md'].includes(ext);
                    });
                    
                    if (imageFiles.length > 0) {
                        const banner = document.getElementById('autoLoadBanner');
                        banner.style.display = 'block';
                        banner.innerHTML = `üñºÔ∏è Found ${imageFiles.length} image file(s). Please drag them to the <strong>Images</strong> tab instead!`;
                        banner.style.background = '#ffc107';
                        banner.style.color = '#856404';
                        setTimeout(() => {
                            banner.style.display = 'none';
                            banner.style.background = '';
                            banner.style.color = '';
                        }, 5000);
                    } else if (documentFiles.length > 0) {
                        const banner = document.getElementById('autoLoadBanner');
                        banner.style.display = 'block';
                        banner.innerHTML = `üìÑ Found ${documentFiles.length} document file(s). Please drag them to the <strong>Documents</strong> tab instead!`;
                        banner.style.background = '#ffc107';
                        banner.style.color = '#856404';
                        setTimeout(() => {
                            banner.style.display = 'none';
                            banner.style.background = '';
                            banner.style.color = '';
                        }, 5000);
                    } else if (allFiles.length > 0 && audioFilesFromDrop.length === 0) {
                        alert(`${allFiles.length} file(s) are not supported audio formats. Please use MP3, WAV, FLAC, AAC, OGG, or M4A files.`);
                    }
                }

                if (audioFilesFromDrop.length > 0) {
                    loadAudioFiles(audioFilesFromDrop);
                }
            }
        }

        // ===== VIDEO FUNCTIONALITY =====

        // Video model change handler
        async function handleVideoModelChange() {
            const select = document.getElementById('videoAiModel');
            const newModelType = select.value;
            
            if (newModelType !== videoModelType) {
                videoModelType = newModelType;
                videoModelLoaded = false;
                updateVideoAnalyzeButton();
                await loadVideoModel();
            } else if (!videoModelLoaded) {
                // If model type is the same but model isn't loaded, load it
                await loadVideoModel();
            }
        }

        async function loadVideoModel() {
            try {
                console.log('Starting video model loading process...');
                videoModelLoaded = false;
                updateVideoAnalyzeButton();
                
                const config = videoModelConfigs[videoModelType];
                console.log(`Loading ${config.name} model...`);
                
                // Simulate realistic model loading time
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                videoCurrentModel = await config.loadModel();
                console.log('Video model loadModel() completed, setting videoModelLoaded = true');
                videoModelLoaded = true;
                updateVideoAnalyzeButton();
                
                console.log(`${config.name} model loaded successfully, videoModelLoaded = ${videoModelLoaded}`);
                
                // Show success banner
                const banner = document.getElementById('autoLoadBanner');
                if (banner) {
                    banner.style.display = 'block';
                    banner.innerHTML = `üß† ${config.name} video model loaded successfully!`;
                    setTimeout(() => banner.style.display = 'none', 2000);
                }
            } catch (error) {
                console.error('Error loading video model:', error);
                videoModelLoaded = false;
                updateVideoAnalyzeButton();
            }
        }

        function selectVideoFiles() {
            const input = document.createElement('input');
            input.type = 'file';
            input.multiple = true;
            input.accept = 'video/*,.mp4,.avi,.mov,.wmv,.mkv,.webm,.flv,.3gp';
            input.onchange = (e) => loadVideoFiles(Array.from(e.target.files));
            input.click();
        }

        function selectVideoFolder() {
            const input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.multiple = true;
            input.onchange = (e) => {
                const videoFilesFromFolder = Array.from(e.target.files).filter(file => 
                    file.type.startsWith('video/') || 
                    file.name.toLowerCase().match(/\.(mp4|avi|mov|wmv|mkv|webm|flv|3gp)$/i)
                );
                loadVideoFiles(videoFilesFromFolder);
            };
            input.click();
        }

        function loadVideoFiles(files) {
            const newFiles = files.filter(file => {
                return !videoFiles.some(existing => 
                    existing.name === file.name && existing.file.size === file.size
                );
            });
            
            if (newFiles.length === 0) {
                alert('All selected videos are already loaded.');
                return;
            }
            
            const startingId = videoFiles.length;
            const newVideos = newFiles.map((file, index) => ({
                id: startingId + index,
                name: file.name,
                file: file,
                type: getVideoFileType(file.name),
                analyzed: false,
                thumbnail: null
            }));
            
            videoFiles.push(...newVideos);
            
            // Generate thumbnails for new videos
            newVideos.forEach(generateVideoThumbnail);
            
            renderVideoFiles();
            updateVideoStats();
            
            if (newFiles.length < files.length) {
                const duplicates = files.length - newFiles.length;
                alert(`Added ${newFiles.length} new videos. ${duplicates} duplicate(s) were skipped.`);
            }
        }

        function getVideoFileType(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            switch(ext) {
                case 'mp4': return 'mp4';
                case 'avi': return 'avi';
                case 'mov': return 'mov';
                case 'wmv': return 'wmv';
                case 'mkv': return 'mkv';
                case 'webm': return 'webm';
                case 'flv': return 'flv';
                case '3gp': return '3gp';
                default: return 'mp4';
            }
        }

        function generateVideoThumbnail(videoData) {
            const video = document.createElement('video');
            video.preload = 'metadata';
            video.muted = true;
            
            // Create a temporary blob URL for thumbnail generation
            const tempBlobURL = URL.createObjectURL(videoData.file);
            
            video.onloadedmetadata = function() {
                video.currentTime = Math.min(video.duration * 0.1, 10);
            };
            
            video.onseeked = function() {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = Math.min(video.videoWidth, 320);
                    canvas.height = Math.min(video.videoHeight, 240);
                    
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    videoData.thumbnail = canvas.toDataURL('image/jpeg', 0.8);
                    
                    const thumbnailElement = document.querySelector(`[data-video-id="${videoData.id}"] .video-thumbnail video`);
                    if (thumbnailElement) {
                        thumbnailElement.poster = videoData.thumbnail;
                    }
                } catch (error) {
                    console.log('Error creating thumbnail for:', videoData.name, error);
                } finally {
                    URL.revokeObjectURL(tempBlobURL);
                }
            };
            
            video.onerror = function(error) {
                console.log('Error loading video for thumbnail:', videoData.name, error);
                URL.revokeObjectURL(tempBlobURL);
            };
            
            video.src = tempBlobURL;
        }

        function renderVideoFiles() {
            const grid = document.getElementById('videoGrid');
            grid.innerHTML = '';
            
            videoFiles.forEach(videoFile => {
                const card = createVideoCard(videoFile);
                grid.appendChild(card);
            });
        }

        function createVideoCard(videoData) {
            const card = document.createElement('div');
            card.className = 'video-card';
            card.setAttribute('data-video-id', videoData.id);
            
            const analysisData = videoAiData[videoData.name];
            const aiIndicator = analysisData ? 'style="display: block;"' : 'style="display: none;"';
            
            card.innerHTML = `
                <div class="video-header">
                    <div class="video-type ${videoData.type}">${videoData.type.toUpperCase()}</div>
                    <div class="ai-indicator" data-id="${videoData.id}" ${aiIndicator}>
                        ${videoModelConfigs[videoModelType].icon} Analyzed
                    </div>
                </div>
                <div class="video-content">
                    <div class="video-title">${videoData.name}</div>
                    <div class="video-attributes" data-id="${videoData.id}" style="display: block;">
                        <div class="attribute-row">
                            <span class="attribute-label">Size:</span>
                            <span>${formatFileSize(videoData.file.size)}</span>
                        </div>
                        <div class="attribute-row">
                            <span class="attribute-label">Modified:</span>
                            <span>${formatDate(videoData.file.lastModified)}</span>
                        </div>
                    </div>
                    <div class="video-thumbnail" onclick="showVideoPlayer(${videoData.id})">
                        <video poster="${videoData.thumbnail || ''}"></video>
                        <div class="play-icon">‚ñ∂</div>
                    </div>
                    <div class="video-summary" data-id="${videoData.id}" onclick="editVideoSummary(${videoData.id})">
                        ${videoSummaries[videoData.name] || 'Click to add summary...'}
                    </div>
                    <div class="video-tags" data-id="${videoData.id}"></div>
                    <div class="confidence-score" data-id="${videoData.id}"></div>
                </div>
            `;
            
            if (analysisData) {
                updateVideoCard(videoData.id, analysisData);
            }
            
            return card;
        }

        function showVideoPlayer(videoId) {
            const videoData = videoFiles.find(video => video.id === videoId);
            if (!videoData) return;
            
            const modal = document.getElementById('videoPlayerModal');
            const title = document.getElementById('videoPlayerTitle');
            const player = document.getElementById('videoPlayerElement');
            
            // Clean up any existing URL
            if (player.src && player.src.startsWith('blob:')) {
                URL.revokeObjectURL(player.src);
            }
            
            title.textContent = videoData.name;
            
            // Create a fresh blob URL for playing
            const freshBlobURL = URL.createObjectURL(videoData.file);
            player.src = freshBlobURL;
            
            // Store the blob URL for cleanup
            player.dataset.blobUrl = freshBlobURL;
            
            modal.classList.add('active');
            
            // Auto-play with error handling
            player.play().catch(error => {
                console.error('Error playing video:', error);
                alert('Unable to play this video. The file format might not be supported.');
            });
        }

        function closeVideoPlayer() {
            const modal = document.getElementById('videoPlayerModal');
            const player = document.getElementById('videoPlayerElement');
            
            player.pause();
            player.currentTime = 0;
            
            // Clean up the blob URL
            if (player.dataset.blobUrl) {
                URL.revokeObjectURL(player.dataset.blobUrl);
                delete player.dataset.blobUrl;
            }
            
            player.src = '';
            modal.classList.remove('active');
        }

        function editVideoSummary(videoId) {
            const summaryElement = document.querySelector(`[data-id="${videoId}"].video-summary`);
            const currentSummary = summaryElement.textContent;
            const isPlaceholder = currentSummary === 'Click to add summary...';
            
            summaryElement.contentEditable = true;
            
            if (isPlaceholder) {
                summaryElement.textContent = '';
                summaryElement.focus();
                const range = document.createRange();
                const sel = window.getSelection();
                range.setStart(summaryElement, 0);
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
            } else {
                summaryElement.focus();
                document.execCommand('selectAll', false, null);
            }
            
            summaryElement.onblur = () => {
                summaryElement.contentEditable = false;
                const newSummary = summaryElement.textContent.trim();
                const videoName = videoFiles[videoId].name;
                
                if (newSummary === '') {
                    summaryElement.textContent = 'Click to add summary...';
                    delete videoSummaries[videoName];
                } else {
                    videoSummaries[videoName] = newSummary;
                }
            };
            
            summaryElement.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    summaryElement.blur();
                }
            };
        }

        function updateVideoCard(videoId, data) {
            const aiIndicator = document.querySelector(`[data-id="${videoId}"].ai-indicator`);
            const tagsContainer = document.querySelector(`[data-id="${videoId}"].video-tags`);
            const confidenceScore = document.querySelector(`[data-id="${videoId}"].confidence-score`);
            
            if (aiIndicator) {
                aiIndicator.style.display = 'block';
            }
            
            if (data.tags && tagsContainer) {
                const tagsHtml = data.tags.slice(0, 5).map(tag => 
                    `<span class="tag">${tag.word}</span>`
                ).join('');
                tagsContainer.innerHTML = tagsHtml;
            }
            
            if (confidenceScore && data.tags) {
                const avgConfidence = data.tags.reduce((sum, tag) => sum + tag.score, 0) / data.tags.length;
                confidenceScore.innerHTML = `
                    <div class="confidence-text">
                        ${Math.round(avgConfidence * 100)}% confidence ‚Ä¢ ${data.tags.length} tags
                    </div>
                `;
            }
        }

        async function analyzeVideos() {
            if (!videoModelLoaded || isVideoAnalyzing || videoFiles.length === 0) {
                if (!videoModelLoaded) {
                    alert('Please wait for the video model to load before analyzing.');
                }
                return;
            }
            
            const unanalyzedVideos = videoFiles.filter(video => !videoAiData[video.name]);
            if (unanalyzedVideos.length === 0) {
                alert('All videos have already been analyzed with the current model.');
                return;
            }
            
            isVideoAnalyzing = true;
            updateVideoAnalyzeButton();
            
            const banner = document.getElementById('autoLoadBanner');
            banner.style.display = 'block';
            banner.innerHTML = `üé¨ Analyzing ${unanalyzedVideos.length} videos with ${videoModelConfigs[videoModelType].name}...`;
            
            try {
                for (let i = 0; i < unanalyzedVideos.length; i++) {
                    const video = unanalyzedVideos[i];
                    
                    try {
                        const analysis = await videoCurrentModel.analyze(video);
                        videoAiData[video.name] = {
                            tags: analysis.tags || [],
                            scene: analysis.scene || 'Unknown',
                            activity: analysis.activity || 'Unknown',
                            embedding: analysis.embedding || [],
                            modelUsed: videoModelConfigs[videoModelType].name,
                            timestamp: new Date().toISOString()
                        };
                        
                        updateVideoCard(video.id, videoAiData[video.name]);
                        video.analyzed = true;
                    } catch (error) {
                        console.error(`Error analyzing ${video.name}:`, error);
                    }
                    
                    // Update progress
                    const progress = ((i + 1) / unanalyzedVideos.length) * 100;
                    banner.innerHTML = `üé¨ Analyzing videos... (${i + 1}/${unanalyzedVideos.length}) - ${Math.round(progress)}%`;
                    
                    // Small delay to prevent blocking
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                banner.innerHTML = `ü§ñ Video analysis complete! Analyzed ${unanalyzedVideos.length} videos with ${videoModelConfigs[videoModelType].name}.`;
                setTimeout(() => banner.style.display = 'none', 4000);
                
            } catch (error) {
                console.error('Video analysis failed:', error);
                banner.innerHTML = '‚ùå Video analysis failed. Please try again.';
                setTimeout(() => banner.style.display = 'none', 3000);
            }
            
            isVideoAnalyzing = false;
            updateVideoStats();
            updateVideoAnalyzeButton();
        }

        function updateVideoAnalyzeButton() {
            const btn = document.getElementById('videoAiAnalyzeBtn');
            if (!btn) {
                console.log('updateVideoAnalyzeButton: button not found');
                return;
            }
            console.log(`updateVideoAnalyzeButton: videoModelLoaded=${videoModelLoaded}, videoFiles.length=${videoFiles.length}, isVideoAnalyzing=${isVideoAnalyzing}`);
            
            btn.disabled = !videoModelLoaded || videoFiles.length === 0 || isVideoAnalyzing;
            
            if (isVideoAnalyzing) {
                btn.textContent = 'üîÑ Analyzing...';
                btn.classList.add('loading');
            } else if (!videoModelLoaded) {
                btn.textContent = '‚è≥ Loading Model...';
                btn.classList.add('loading');
            } else if (videoFiles.length === 0) {
                btn.textContent = 'üé¨ AI Analyze';
                btn.classList.remove('loading');
            } else {
                btn.textContent = 'üé¨ AI Analyze';
                btn.classList.remove('loading');
            }
            console.log(`updateVideoAnalyzeButton: final button text = "${btn.textContent}"`);
        }

        function updateVideoStats() {
            const videoCountEl = document.getElementById('videoCount');
            const analyzedCountEl = document.getElementById('videoAnalyzedCount');
            
            if (videoCountEl) videoCountEl.textContent = videoFiles.length;
            if (analyzedCountEl) analyzedCountEl.textContent = Object.keys(videoAiData).length;
            
            updateVideoAnalyzeButton();
        }

        function updateVideoGridSize(value) {
            const grid = document.getElementById('videoGrid');
            if (grid) {
                grid.className = `video-grid grid-${value}`;
            }
        }

        function toggleVideoFileInfo(checked) {
            const attrs = document.querySelectorAll('.video-attributes');
            attrs.forEach(attr => {
                attr.style.display = checked ? 'block' : 'none';
            });
        }

        function clearVideoGrid() {
            if (videoFiles.length === 0) return;
            
            if (confirm('Are you sure you want to clear all videos? This will remove all loaded videos and analysis data.')) {
                // Close video player if open and clean up its blob URL
                const player = document.getElementById('videoPlayerElement');
                if (player && player.dataset.blobUrl) {
                    URL.revokeObjectURL(player.dataset.blobUrl);
                    delete player.dataset.blobUrl;
                    player.src = '';
                }
                closeVideoPlayer();
                
                videoFiles = [];
                videoAiData = {};
                videoSummaries = {};
                renderVideoFiles();
                updateVideoStats();
                
                const banner = document.getElementById('autoLoadBanner');
                banner.style.display = 'block';
                banner.innerHTML = 'üóëÔ∏è Video grid cleared successfully.';
                setTimeout(() => banner.style.display = 'none', 2000);
            }
        }

        function exportVideoMetadata() {
            if (videoFiles.length === 0) {
                alert('No videos to export. Please load some videos first.');
                return;
            }
            
            const metadata = {
                appName: 'AI Content Manager - Videos',
                modelUsed: videoModelConfigs[videoModelType].name,
                totalVideos: videoFiles.length,
                summaries: videoSummaries,
                aiData: videoAiData
            };

            const json = JSON.stringify(metadata, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `video-metadata-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importVideoMetadata() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const metadata = JSON.parse(e.target.result);
                        
                        if (metadata.summaries) {
                            Object.assign(videoSummaries, metadata.summaries);
                        }
                        if (metadata.aiData) {
                            Object.assign(videoAiData, metadata.aiData);
                        }
                        
                        renderVideoFiles();
                        updateVideoStats();
                        
                        const aiCount = Object.keys(metadata.aiData || {}).length;
                        const summaryCount = Object.keys(metadata.summaries || {}).length;
                        
                        const banner = document.getElementById('autoLoadBanner');
                        banner.style.display = 'block';
                        banner.innerHTML = `üìÇ Imported ${aiCount} AI analysis records and ${summaryCount} summaries!`;
                        setTimeout(() => banner.style.display = 'none', 3000);
                    } catch (error) {
                        alert('Failed to import data. Please check the file format.');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function openVideoSearch() {
            if (videoFiles.length === 0) {
                alert('No videos loaded. Please load videos first.');
                return;
            }
            
            // Show video search modal
            const existingModal = document.getElementById('videoSearchModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            const modalHtml = `
                <div id="videoSearchModal" style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                " onclick="closeVideoSearch()">
                    <div style="
                        background: white;
                        padding: 30px;
                        border-radius: 12px;
                        width: 90%;
                        max-height: 80%;
                        overflow-y: auto;
                        cursor: default;
                    " onclick="event.stopPropagation()">
                        <h2 style="margin-bottom: 20px; color: #333;">üîç Search Videos</h2>
                        <input type="text" id="videoSearchInput" placeholder="Search by filename, AI tags, scenes, activities..." style="
                            width: 100%;
                            padding: 12px;
                            border: 2px solid #ddd;
                            border-radius: 6px;
                            font-size: 16px;
                            margin-bottom: 15px;
                        " oninput="handleVideoSearchInput()" onkeydown="handleVideoSearchKeydown(event)">
                        
                        <div style="margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 8px;">
                            <span onclick="performVideoSearch('cooking')" style="background: #e9ecef; padding: 6px 12px; border-radius: 16px; cursor: pointer; font-size: 12px;">cooking</span>
                            <span onclick="performVideoSearch('nature')" style="background: #e9ecef; padding: 6px 12px; border-radius: 16px; cursor: pointer; font-size: 12px;">nature</span>
                            <span onclick="performVideoSearch('family')" style="background: #e9ecef; padding: 6px 12px; border-radius: 16px; cursor: pointer; font-size: 12px;">family</span>
                            <span onclick="performVideoSearch('tutorial')" style="background: #e9ecef; padding: 6px 12px; border-radius: 16px; cursor: pointer; font-size: 12px;">tutorial</span>
                            <span onclick="performVideoSearch('outdoor')" style="background: #e9ecef; padding: 6px 12px; border-radius: 16px; cursor: pointer; font-size: 12px;">outdoor</span>
                            <span onclick="performVideoSearch('travel')" style="background: #e9ecef; padding: 6px 12px; border-radius: 16px; cursor: pointer; font-size: 12px;">travel</span>
                        </div>
                        
                        <div id="videoSearchResults" style="margin-top: 20px;"></div>
                        
                        <button onclick="closeVideoSearch()" style="
                            margin-top: 20px;
                            padding: 10px 20px;
                            background: #6c757d;
                            color: white;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                        ">Close</button>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            document.getElementById('videoSearchInput').focus();
        }
        
        function closeVideoSearch() {
            const modal = document.getElementById('videoSearchModal');
            if (modal) {
                modal.remove();
            }
        }
        
        function handleVideoSearchInput() {
            const query = document.getElementById('videoSearchInput').value.trim();
            if (query.length > 2) {
                setTimeout(() => performVideoSearch(), 300);
            } else {
                document.getElementById('videoSearchResults').innerHTML = '';
            }
        }
        
        function handleVideoSearchKeydown(event) {
            if (event.key === 'Enter') {
                performVideoSearch();
            }
        }
        
        function performVideoSearch(predefinedQuery = '') {
            const query = predefinedQuery || document.getElementById('videoSearchInput').value.trim().toLowerCase();
            const resultsContainer = document.getElementById('videoSearchResults');
            
            if (predefinedQuery) {
                document.getElementById('videoSearchInput').value = predefinedQuery;
            }
            
            if (!query) {
                resultsContainer.innerHTML = '';
                return;
            }
            
            if (videoFiles.length === 0) {
                resultsContainer.innerHTML = '<p>No videos loaded. Please load videos first.</p>';
                return;
            }
            
            const results = searchInVideos(query);
            displayVideoSearchResults(results, resultsContainer);
        }
        
        function searchInVideos(query) {
            const results = [];
            
            videoFiles.forEach(video => {
                const data = videoAiData[video.name];
                let score = 0;
                const queryTerms = query.split(' ').filter(term => term.length > 0);
                
                // Search in filename (highest priority for exact matches)
                queryTerms.forEach(term => {
                    const fileName = video.name.toLowerCase();
                    if (fileName.includes(term)) {
                        // Boost score more for exact word matches in filename
                        if (fileName.split(/[._-]/).some(part => part === term)) {
                            score += 1.2;
                        } else {
                            score += 0.9;
                        }
                    }
                });
                
                // Search in summaries/descriptions (high priority)
                const summary = videoSummaries[video.name];
                if (summary) {
                    queryTerms.forEach(term => {
                        if (summary.toLowerCase().includes(term)) {
                            score += 1.0;
                        }
                    });
                }
                
                // Search in AI tags/classifications (if video analyzed)
                if (data && data.tags) {
                    queryTerms.forEach(term => {
                        data.tags.forEach(tag => {
                            const tagLower = tag.word ? tag.word.toLowerCase() : tag.toLowerCase();
                            if (tagLower === term) {
                                // Exact tag match gets high score
                                score += (tag.score || 0.8) * 0.9;
                            } else if (tagLower.includes(term)) {
                                // Partial tag match gets medium score
                                score += (tag.score || 0.8) * 0.7;
                            }
                        });
                    });
                }
                
                // Search in AI scene descriptions
                if (data && data.scene) {
                    queryTerms.forEach(term => {
                        if (data.scene.toLowerCase().includes(term)) {
                            score += 0.7;
                        }
                    });
                }
                
                // Search in AI activities
                if (data && data.activity) {
                    queryTerms.forEach(term => {
                        if (data.activity.toLowerCase().includes(term)) {
                            score += 0.6;
                        }
                    });
                }
                
                // Include results with any score > 0 OR filename matches (even without AI analysis)
                if (score > 0) {
                    results.push({
                        video: video,
                        data: data || null,
                        score: Math.min(score, 2.0)
                    });
                }
            });
            
            return results.sort((a, b) => b.score - a.score).slice(0, 20);
        }
        
        function displayVideoSearchResults(results, container) {
            if (results.length === 0) {
                container.innerHTML = '<p style="color: #666;">No matching videos found.</p>';
                return;
            }
            
            const html = results.map((result, index) => `
                <div onclick="playVideoFromSearch(${result.video.id})" style="
                    padding: 12px;
                    border: 1px solid #ddd;
                    border-radius: 6px;
                    margin-bottom: 8px;
                    cursor: pointer;
                    transition: background 0.2s;
                " onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='white'">
                    <div style="font-weight: 600; color: #333; margin-bottom: 4px;">
                        ${result.video.name}
                        <span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 8px;">
                            ${getVideoFileType(result.video.name).toUpperCase()}
                        </span>
                    </div>
                    <div style="font-size: 12px; color: #28a745; font-weight: 500; margin-bottom: 4px;">
                        Match score: ${Math.round(result.score * 100)}%
                    </div>
                    <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
                        ${result.data && result.data.tags ? 
                            'Tags: ' + result.data.tags.slice(0, 3).map(tag => tag.word || tag).join(', ') : 
                            'No AI analysis data'}
                    </div>
                    <div style="font-size: 11px; color: #999; opacity: 0.7;">
                        Click to play video
                    </div>
                </div>
            `).join('');
            
            container.innerHTML = html;
        }
        
        function playVideoFromSearch(videoId) {
            closeVideoSearch();
            showVideoPlayer(videoId);
        }

        function setupVideoDragDrop() {
            const content = document.getElementById('videosContent');
            if (!content) return;
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // Add drag and drop event listeners
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                content.addEventListener(eventName, preventDefaults, false);
            });

            ['dragenter', 'dragover'].forEach(eventName => {
                content.addEventListener(eventName, () => {
                    const dragDropArea = document.getElementById('videoDragDropArea');
                    if (dragDropArea) dragDropArea.classList.add('drag-over');
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                content.addEventListener(eventName, () => {
                    const dragDropArea = document.getElementById('videoDragDropArea');
                    if (dragDropArea) dragDropArea.classList.remove('drag-over');
                }, false);
            });

            content.addEventListener('drop', handleVideoDrop, false);

            function handleVideoDrop(e) {
                const dt = e.dataTransfer;
                const files = Array.from(dt.files);
                const videoFilesFromDrop = files.filter(file => 
                    file.type.startsWith('video/') || 
                    file.name.toLowerCase().match(/\.(mp4|avi|mov|wmv|mkv|webm|flv|3gp)$/i)
                );
                if (videoFilesFromDrop.length > 0) {
                    loadVideoFiles(videoFilesFromDrop);
                }
            }
        }

        // Initialize audio model and drag-drop on load
        setTimeout(() => {
            handleAudioModelChange();
            setupAudioDragDrop();
            handleVideoModelChange(); // Initialize video model too
            setupVideoDragDrop(); // Initialize video drag-drop too
        }, 1500);

    </script>
</body>
</html>